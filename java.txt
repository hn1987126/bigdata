1、父类或接口名 创建对象，用子类来 new ，这个对象如果调 属性是调 的父类的，如果调 方法则是调 子类的。
如 class A;
 class B extends A;
  A a = new B();
2、类继承了一个接口，接口里没有定义方法，而子类里有。则会编译错误。
3、父类有一个方法，如果子类里再有一个相同的，但是是prive私有的，则会出错。或者父亲和子类方法名参数名一致，但是返回值类型不一致也会编译错误，因为方法歧义。
4、对象 print的时候，会打印哈希值出来，如果想打印的好看，在类中重写下toString方法来输出类的属性。
5、Ascii码转为字符   (char)97   得到 b
\r   的Asicc码是 13
\n   的Asicc码是 10
     比如 int a = 10; 可以直接这样比较 if (a == '\n'){}
     iso8859-1 是拉丁语表。
6、集合清空是 clear，StringBuffer和StringBuilder清空是 delete。
7、java中字符用unicode码，中文用gbk码。全世界通用，两个字节表示全世界的文字。
如果是a,b这种字符，会在他前面加上 8个0，最后是全世界两位。
由于2个字节来装，太占空间了，后来产生了utf-8编码，有几个就占几个。utf-8里一个中文占3个字节
8、字节(byte)，位(bit)，的概念
1个字节也就是1个英文字符，gbk编码下1个中文是2字节，utf-8编码下1个中文是3个字节
1个字节等于8位。
1024个byte是 1kb
char、byte、int对于英文字符，可以相互转化

9、整数在内存中占4个字节。
10、端口号 是0-65535之间的数字，0-1024之间的端口系统在用，我们的应用最好不要用这些端口。
11、192.168.31.255   这最后一位是255的，是代表广播地址，往这个地址上发信息，会往所有  192.168.31.1 到时 192.168.31.254 之间的ip发信息。
12、文件流缓冲区默认大小是 8*1024字节，也就是8kb。
13、知识：为什么很多东西如类的toString方法里把hashcode转为16进制。是因为 进制越大，长度越短。你看，2进制是长度最长的。
14、同时定义三个变量   int a,b,c = 0;


进程：正在进行中的程序
线程：就是进程中 一个负责程序执行的控制单元（执行路径）。一个进程中至少要有一个线程，称为主线程。
多线程：多条执行路径同时进行。
开启多个线程，是为了同时运行多部分代码。每一个线程都有自己运行的内容，这个内容称为线程要执行的任务。
他们同时进行。
多线程的弊端：线程太多回收效率降低
其实应用程序的执行都是cpu在做着快速的切换完成的。这个切换是随机的。

JVM启动时就自动启了多个线程，至少有两个线程可以分析出来
1、执行main函数的线程。 该线程的任务代码都定义在main函数中。
2、负责垃圾回收的线程。  他的任务代码是在垃圾回收器里定义的。底层内部完成。
垃圾回收：System.gc();
在垃圾回收的时候，在类里，可以写个 finalize() 方法，在gc的时候，会调用那个方法，那方法里可以做一些保存呀，发消息呀之类的事件处理。
class Demo extends Object{
    public void finalize(){
        System.out.println("gc demo");
    }
}
class ThreadDemo{
    public static void main(String[] args){
        new Demo(); // 匿名类产生垃圾
        System.gc();
        System.out.println("main ok");
    }
}
主线程结束了，也就是main里的代码执行到最后一行，不代表jvm虚拟机就结束了，虚拟机里还有其他线程在执行。

创建线程方式：
继承Thread类。
实现Runnable接口。
-> 好处：1、将线程的任务从线程的子类中分离出来进行了单独封装，按面向对象的思想将任务封装成对象
2、避免了java单继承的局限性。
所以创建线程的第二种方式更常用。

主线程如果挂了，子线程还是会执行的。
CPU的执行资格   可以被cpu处理，在处理队列中排队
CPU的执行权     正在被cpu处理。

线程的5种状态：
被创建
运行状态   有cpu的执行资格和执行权
冻结状态   释放执行权的同时释放执行资格，没有cpu的执行资格和执行权。
消亡状态
临时阻塞状态     具备执行资格，但是不具备执行权，正在等待执行权，是临时阻塞。他和运行状态，两者不断的切换。
->如A,B,C,D4个线程同时执行，当cpu正在执行A的时候，bcd是临时阻塞状态。

sleep(1000)   等待，1秒后又重新有了执行权和执行资格。

------ 等待唤醒机制
wait()   等待   需要靠 notify() 唤醒，他才能重新争夺执行权和执行资格。让线程处于冻结状态，被wait的线程会被存储到线程池中。
notify() 唤醒同锁线程池中的一个线程(任意)
notifyAll() 唤醒同锁线程池中的所有线程，让他们具有被cpu执行的资格
以上这三个方法必须定义在同步中。因为这些方法是用于操作线程状态的方法。必须要明确到底操作的是哪个锁上的线程。
操作这三个方法，前面需要加上锁名.，也就是锁那个对象，如，obj.wait()

栈内存  main方法执行，里面调了a方法，b方法，那main先入栈，a再入栈，执行完a后，a出栈，b再入栈，b执行完了b出栈，main再出栈。如果出异常，则立即出栈。
堆内存  如成员变量。

##异常会包含4部分信息：
线程，异常类型，异常信息，在什么位置。

线程安全问题产生的原因：
1、多个线程在操作共享的数据。
2、操作共享数据的线程代码有多条。
当一个线程在执行操作共享数据的多条代码过程中，其他线程参与了运算。就会导致线程安全问题的产生。
因为可能有多条语句，执行完其中一条，那cpu就可能切走了，在没有减之前，别的线程就进来了。
解决思路：
将多条操作共享数据的线程代码封装起来，当有线程在执行这些代码的时候，其他线程不可以进来。
解决办法：
一、同步代码块
synchronized(对象){  // 这个对象就直接用this就行
    需要被同步的代码，也就是不安全操作的那几条代码
}
同步的好处：解决线程安全问题
弊端：相对降低了效率。因为同步外的线程都会不停的判断同步锁。
同步的前提：必须有多个线程，并他们使用同一个锁。

二、同步函数：里面的锁对象是 this
与同步代码块一样，只不过刚好需要同步的代码就在一个函数中，就省得再多写 synchronized(对象){}，只需要在函数前面加个修饰符
public synchronized void funcA() {}

三、静态同步函数  里面的锁对象是 ：  this.getClass()、类名.class
该函数所属的字节码文件对象  是  类名.class(class是属性，任何类都有)，或对象.getClass()，(这个类的任意的对象)
## 字节码文件对象，也就是静态类，静态方法，等他们一开始加载到内存时，他们所在的对象，也就是类本身：
Class clazz = Object.class;(类名.class)    或  Class clazz = t.getClass()  对象.getClass() 【用对象去获取(t是new出来的对象)，或者 this.getClass();】
在静态方法里，如果要加同步代码块，那对象只能是 类名.class这种形式。因为那会还没有this，也没有obj

单例模式有两种形式，一种是饿汉式的，一种是懒汉式的。饿汉式是在类加载到内存时，便把对象new出来了，getInstance方法中只是返回，这不会出现多线程安全问题。
懒汉式是，类加载时不new对象，在getInstance方法中判断如果为null再new，这时就因为这一个判断，是多条语句，就产生了安全问题。需要加同步代码块锁来解决。

死锁：是指同步块嵌套同步块，或同步函数里有同步块，这种我拿着我的锁不放，你拿着你的锁不放，导致我执行不到你的代码块，你执行不了我的代码块。程序就僵持在那里。

### 线程间通信：
多个线程在处理同一资源，但是任务却不同。举例：火车把煤运来了，汽车要把煤拉走。他们是不同的任务，不同的线程，但是资源是同一个。

### 锁对象Lock
 * Lock接口  代替了synchronized
 * condition接口   代替了object锁名
 * jdk1.5之后，把同步代码块，这种隐式锁，替换成了Lock对象，将隐式动作变成了显式动作(封装到lock对象的方法中了)
 可以一个锁上加多个监视器。
 lockObj.lock()  获取锁
 lockObj.unlock()   释放锁，通常需要定义在finally代码块中

 Condition接口【监视器】：替代了Object中的wait notify notifyAll方法。
 将这些监视器方法单独进行了封装，变成Condition监视器对象。可以和任意锁进行组合。

 中止线程：interrupt()
 它是将线程从冻结状态强制恢复到运行状态中来，使线程具备cpu的执行资格。
 当强制动作发生了InterruptedException，记得要处理。

 守护线程或用户线程、联合进程：   setDaemon(true),在启动线程之前调用。
 它也叫 后台进程。只要前台进程都结束了，后台进程也就结束了。前台进程就是没加这个的那些进程。
 举例：你负责输入，我负责输出，你不输入我就不输出，你要是结束了，我也就结束了。我是后台进程。用在这里。

 join方法。临时加入一个线程运算，其他的线程要等这个线程运算完才能算。
 如  thread1.join()  这个方法的名字叫，"等待线程终止"。在哪个线程如主线程，执行到 join方法，那个线程就让出执行权，其他的都等待。

 toString()方法，Thread.currentThread().toString()   线程对象的字符串
 优先级：
 thread1.setPriority(Thread.MAX_PRIORITY)   // 争夺cpu执行权的 最大优先级，还有最小Thread.MIN_PRIORITY 和默认Thread.NORM_PRIORITY
 线程组：  今后可以对一组线程进行操作。
 new Thread(new ThreadGroup(), Runnable target)
 释放cpu执行权，自己和其他线程都有再抢夺的机会，这样使执行更均衡一些
 thread1.yield();




///----------------------------------------------------------------------------------------------------------------------
1、字符串比较，忽略大小写：
"ab".equalsIgnoreCase("AB")
2、字符串中是否包含指定字符串
"ab".contains("a");
3、字符串是否以 指定字符串开头和结尾
"ab".startsWith("a")  或    endsWith("b")
4、字符串比较,按字典顺序比较两个字符串 compareTo，返回两个字的字典差距（返回0，大于0的整数，小于0的整数）
前面的比后面大，返回正数，比后面小返回负数，相同返回0
"be".compareTo("ba")    返回4
5、indexOf  找子串第一次出现的位置，如果没找到返回-1.
"abc".indexOf("d")     可以传第二个参数，代表从哪个位置开始找
"abca".indexOf("a", 2)

/// -------------
StringBuffer 字符缓冲区
StringBuffer sb = new StringBuffer();
sb.append("sb").append(true);
sb.insert(1, "sbsb");  // 在指定位置插入
sb.delete(start, end)  // 包含头不包含尾，从第start位开始删除，删到end，不包含end
sb.deleteCharAt(int index)   // 删除指定的一个
sb.delete(0, sb.length())    // 清空缓冲区
查找
sb.charAt(index)         查找字符，返回char
sb.indexOf(string)
sb.lastIndexOf(string)
替换
sb.replace(1,2,"ss")   把1到2位，替换为ss

/// --------------
StringBuilder 与 StringBuffer等价。他是jdk1.5才出现的，而StringBuffer是jdk1.1就出现了。
StringBuilder不保证线程同步，也就是线程不安全。而StringBuffer是线程安全。
如果是单线程的，还是要用 StringBuilder,因为他不同步，所以速度快效率高。

jdk升级的目的：
1、简化书写
2、提高效率
3、增加安全性

/// ---------------
基本类型包装类
int Integer
byte Byte
short Short
long  Long
float  Float
double  Double
char  Character
boolean  Boolean


Interger.valueOf("12345")  等价于
Interger.parseInt("12345")
字符串转为基本类型： 使用包装类的静态方法   xxx  parseXxx("xxx类型的字符串")
int parseInt("123")
long parseLong("123")
Integer 包装类型转为基本类型    非静态方法  intValue()

Integer进制转换：
System.out.println(Integer.toBinaryString(10)); // 二进制
System.out.println(Integer.toHexString(10)); // 十六进制
System.out.println(Integer.toOctalString(10)); // 八进制
System.out.println(Integer.toString(60, 8)); // 转八进制，后面的进制随便自己传

// 其他进制转 2进制，后面的radix参数是随便自己传
System.out.println(Integer.parseInt("110", 2));


########################################################################################################
###################### 集合
########################################################################################################
集合的特点：
1、用于存储对象的容器
2、集合的长度是可变的
3、集合中不可以存储基本数据类型值
4、集合打印时直接打印元素值，方便观看。返回的字符串，直接system.out.println输入。

集合容器因为内部的数据结构不同，有多种具体容器。不断向上抽取，最终形成了集合框架
集合的框架顶层是  Collection
常见的方法：
-添加
boolean add(Obj),
boolean addAll(Collection coll) 添加一组，参数里传个集合进去
-删除
boolean remove(Obj)      // 集合的remove方法是会改变集合长度
boolean removeAll(Collection coll)     // 将两个集合中的相同元素 从调用removeAll方法的集合中删除
void clear()
-判断,是否包含
boolean boolean contains(obj)
boolean containsAll(Collection coll)
boolean isEmpty() 集合中是否有元素
-获取
int size()    元素个数
Iterator<E> iterator()  返回迭代器对象
-其它方法：
boolean retainAll(Collection coll)   取交集，// retainAll功能刚与removeAll相反，把两集合中不同元素 从调用retainAll方法的集合中删除
Object[] toArray   将集合变为数组

#### 迭代器的循环：while循环，下面这种比while更好：
for(Iterator it = coll.iterator(); it.hasNext();){
   System.out.println(it.next());
}

Collection两个派系：
List列表和Set集合（它们两是接口）
|--List     有序（存入和取出的顺序一致），元素都有索引（角标）。元素可以重复。（三个常用的实现类：ArrayList, LinkedList, Vector）
|--Set      元素不能重复，无序。

List：特有的常见方法：有一个共性特点就是都可以操作角标
|--添加：
void add (int index, Obj element)     // 向角标位置添加元素
void addAll(int index, Collection coll)
|--删除
Object remove(int index)
|--修改
Object set(int index, Obj element)  // 修改指定位置的元素
|--获取
Object get(int index)    // 获取单个元素
int indexOf(Obj element)
int lastIndexOf(Obj element)
List subList(int from, int to)    // 获取指定位置区间的列表，包括前面的角标，不包括后面的角标。

|--List能完成对元素的增删改查。
除了Iterator取所有元素外(用while 或 for)，List还有特有的取所有元素方法：
for (int i = 0; i < list.size(); i++) {
    System.out.println(list.get(i));
}
|-- ListIterator 列表迭代器，List特有
在迭代器迭代过程中，不要使用集合操作元素（如修改），会出异常。
可以用Iterrator接口的子接口ListIterator来完成在迭代中对元素进行更多的操作，因为那个listIterator提供了set,remove等方法，可以一边迭代List,一边修改List
List list = new ArrayList();
list.add("abc1");
list.add("abc2");
ListIterator lit = list.listIterator();   // list.listIterator(1); 是从指定位置开始迭代
while (lit.hasNext()) {

    Object obj = lit.next();
    if (obj.equals("abc2")){
        lit.set("abc222");
    }
    if (obj.equals("abc6")){
        lit.remove();
    }
}
System.out.println(list);

// 逆向遍历，hasPrevious相当于hasNext，previous()相当于next()
while (lit.hasPrevious()) {
    System.out.println(lit.previous());
}

|---- List接口的三个常见实现类    ArrayList, LinkedList, Vector
    |-- Vector ： 内部是数组数据结构。内存空间连续。具有List的所有特点。是同步的，线程安全。已过时，基本不用。增删改查都很慢。
    |-- ArrayList ： 内部是数组数据结构，是不同步的，线程不安全。替代了Vector。如果是需要多线程，可以给ArrayList加锁（把添加删除方法放在同一把锁里）。
                     特点是查询快修改慢。查询快的原因，是因为地址连续，只要在那一片空间里查找，所以快。修改慢是因为插入一个元素，得移动其他几乎所有元素。
    |-- LinkedList ：内部是链表结构，非同步。链表这种数据结构，由于每个元素记录了他之后元素的地址，增删改的速度特别快，
                     只需要改变下记录的后面元素的地址，和改变下之前元素中记录的他后面一个元素的地址，不用像数组那样每个元素都进行移动。
                     但是数组结构形式的，查询速度快。而链表形式的查询速度慢。



|-LinkedList特有的方法：   LinkedList link = new LinkedList();
void addFirst(Obj element)    往头部添加
void addLast(Obj element)    往末尾添加
jdk1.6加入了如下替代方法：
offFirst()
offLast()

查询头尾：
getFirst   获取但不移除，如果链表为空，抛出NoSuchElementException
getLast。
jdk1.6加入了如下替代方法：
peekFirst      获取但不移除，如果链表为空，返回null
peekLast

删除：
removeFirst    // 获取并移除，如果链表为空，抛出NoSuchElementException 。removeFirst会返回删除的那个元素。
removeLast
jdk1.6加入了如下替代方法：
pollFirst      获取并移除，如果链表为空，返回null
pollLast


|- 请使用LinkedList来模拟一个堆栈或队列数据结构
|-- 堆栈  先进后出  First in Last out     FILO       举例：吐
|-- 队列  先进先出  First in First out    FIFO       举例：拉屎

// ----------------------------------------------------------
Set ： 元素不可以重复，是无序
|- Set接口中的方法与Collection一致。
子类：也就是实现类  HashSet,TreeSet
|- HashSet ：  内部数据结构是哈希表。无序，迭代也无序，顺序会变化，允许null元素，不同步，线程不安全。性能稳定。
  |- LinkedHashSet         HashSet再加一层链表。查找方便。
|- TreeSet ：  可以对Set集合中的元素进行排序。是不同步的。判断元素唯一性的方法：就是根据比较方法结果是否返回0，是0就是相同元素，不会再存储。在每添加一个元素的时候都会去判断。

哈希算法：
其实底层存的也是类似于Array这样的，只不过查找的时候特别快，因为查找的时候，直接根据元素就能找到位置。
怎么存进去呢？
流程是：来一个元素，根据hashCode，也就是AccIss码，得到一个数值，取模，如算出来的值是100，数组的长度的10，那就100%10，得到0-9之间的数。
按位置存进去。查询的时候，再用同样的算法算得位置，直接把那位置的元素拿出来。
存的时候，因为hashCode可能会把不同的元素算成相同的值（如字符串ab,和ba）。这时会先看那个位置有没有元素，如果有元素，再判断之前存的那个元素和要添加的元素是否相等。
怎么判断相等？直接用 equals方法。注意如果hashCode都不同，那第二步就不需要判断了，直接存即可。
这就使得，哈希列表，肯定不会有重复元素的。上面讲的，如果内容也完全相同，那就直接不存新插入的元素。
如果hashCode相同，内容不同（如ab和ba），则称为哈希冲突，通常不会出现这种情况，因为哈希算法不会是简单的用Acciss码来。
冲突的解决办法：顺延，把新插入元素放在之前元素后面的空位置，如果不够长度会将数组的长度延长。
另外一种是 串连，即那个位置再外挂一个出来，存新插入的元素。
查找的时候也解决了，内部这个位置会记录外挂或顺延这两种方式，得到那个重复hashCode的元素。

String这个类，本身就有hashCode()方法 和 equals()比较内容是否相等的方法。
会根据String自身的特点，进行hash算法。
自己定义的类，因为是继承了Object，也会有hashCode方法和equals方法，如人类，里面有姓名和年龄，
如果想只根据姓名来判断是同一个人，可以重写父类Object的hashCode方法和equals方法。
Object父类的hashCode方法，是native 这个修饰符修饰的，代表着他底层是调 原生态方法，方法对应的实现不是在当前文件，而是在用其他语言（如C和C++）实现的文件中。有这个native就可以省略abstract

**** 重点注意：：：
数据结构不一样，判断元素是否相同(如a.contains(b)和 remove(b))【remove的时候也得先去查找，再删除】 等也不相同：
如ArrayList，他们判断元素相同只是判断 equals这个方法，如默认是判断地址是否相同，可以重写这个方法，来如按姓名和年龄，他们两相同，就可以认为是同一人，不用管地址。
如HaseSet，他就必须同时hashCode相同和equals相同，才是真的相同。
   当然也可以重写他们，如hashCode里自定义算法，如返回的hash值是 return 姓名.hashCode()+age*40 这样的算法。[注意，姓名.hashCode()这是字符串的hashCode，可不是本对象中的]


|----  HashSet 是无序的，不能重复的。
如果我们想要有顺序，可以用HashSet的子类： LinkedHashSet 。就是在HashSet 原有算法、存储 的基础上，再记录了下个元素的位置，做到了有序。
使用和HashSet完全相同： LinkedHashSet是和存储一致的顺序
HashSet hs = new LinkedHashSet();

|-- TreeSet集合也是Set接口里的子类：
他和HashSet不一样，人根本就不看Hashcode，他只看   自己定义的类实现 Comparable接口，实现的方法CompareTo
判断元素唯一性的方法：就是根据比较方法结果是否返回0，是0就是相同元素，不会再存储。在每添加一个元素的时候都会去判断。
这个方法需要在里面比较元素的大小，添加的时候就要，因为那如果不判断，返回0，其他的元素就添加不进去。实现了这个方法，在添加的时候，他就有序了。

// 覆盖比较方法，先比较年龄，再比较姓名。Person类，需要实现Comparable接口，并重写compareTo方法。是写在实体类上的。
@Override
public int compareTo(Object o) {
    int temp = this.age - s.age;
    return temp == 0 ? this.name.compareTo(s.name) : temp;
}

|-- TreeSet对元素进行排序的方式一：   在实体类上实现Comparable接口 并重写 compareTo方法
就是上面那种，让元素也就是自己定义的类，自身具备比较功能，就需要实现Comparable接口，覆盖里面的CompareTo方法。
|-- TreeSet对元素进行排序的方式二：   单独再定义一个类 实现Comparator接口并重写 compare方法
如果不要按照对象中具备的自然顺序进行排序，如果对象中不具备自然顺序。如果这个对象根本就不是我们定义的。怎么办？可以使用TreeSet集合的第二种排序方式：
----- 让集合自身具备比较功能。也就是在集合创建的时候，在构造函数里传入一个比较器 Comparator
/**
 * 比较器，需要实现Comparator接口
 */
class ComparatorByName implements Comparator{

    @Override
    public int compare(Object o1, Object o2) {
        Student s1 = (Student) o1;
        Student s2 = (Student) o2;

        int temp = s1.getName().compareTo(s2.getName());
        return temp == 0 ? s1.getAge() - s2.getAge() : temp;
    }
}
如果方式一和方式二都存在了，则以比较器为准，也就是方式二。推荐使用比较器Comparator。怎么用呢？
比如  TreeSet ts = new TreeSet(new ComparatorByName());    在构造方法里传进去，这个ts对象就已经有可比较性了。

|-- TreeSet底层的结构：：二叉树
二叉树怎么提高效率？利用二分折半查找，因为二叉树放完两个元素，他们就已经把顺序排了，再排第10个的时候，前9个已经有顺序了，所以可以用二分法折半查找。



=======================================================================================================================
|--------- 集合框架中，与Collection 同样的顶级 容器， Map
Map一次添加一对元素，Collection一次添加一个元素。
Map也称双列集合，Collection是单列集合。
Map集合中存储的就是键值对。必须保证键的唯一性。
Map集合是无序的。

|-常用方法：
1、添加
value返回值 put(Object key, V value)   // 添加，如果key已经存在，则会新value覆盖原来的值，并返回原来的value，如果不存在则返回null

2、删除
void remove(Object key)   // 删除一个元素
value返回值 clear();   // 移除所有映射关系，返回那个删除的元素

3、判断
boolean containsKey(key);
boolean containsValue(value);
boolean isEmpty();

4、获取
value返回值 get(Object key)   //通过键返回value，如果不存在 返回null，当然可以通过返回null来判断是否包含指定键。
int size()   // 获取键值对的个数
Collection<T> values()   // 取出所有的vlue。values返回Collection，为啥不返回set呢？因为值是不唯一的，而key是唯一的，所以只能返回Collection
Set keySet()    // 取出所有的key
Entry entrySet()   // 取出所有的k,v放入到Entry这种类型的Set中。

##### 取出map的所有元素：
// 方法1：  keySet 可以理解成 丈夫的合集
// 通过keySet方法获取 map中所有的 key 得到set集合,通过set的迭代器获取到每一个键，再对每一个键通过map集合的get方法获取其对应的值即可
Set keySet = map1.keySet();
Iterator it = keySet.iterator();
while (it.hasNext()) {
    System.out.println(map1.get(it.next()));
}

// 方法2：entrySet 可以理解成结婚证书的合集
// 通过Map转换成Set就可以迭代，entrySet方法将键和值的映射关系作为对象存储到Set集合中，而这个映射关系的类型就是Map.Entry类型(结婚证)
Set<Map.Entry<Integer, String>> entries = map1.entrySet();
Iterator<Map.Entry<Integer, String>> it1 = entries.iterator();
while (it1.hasNext()) {
    Map.Entry<Integer, String> en = it1.next();
    System.out.println(en.getKey()+1+"--"+en.getValue());
}

// 只要map里元素的值，不要key，vlues返回Collection，为啥不返回set呢？因为值是不唯一的，而key是唯一的，所以只能返回Collection
System.out.println(map1.values());


|------------- Map常用的子类：
|--HashTable   内部结构是哈希表，是同步的，因为jdk1.0就有了，不支持Null作为键和值。
    |--Properties  用来存储键值对型的配置文件的信息。和IO技术结合才能发挥最大的作用。他是HashTable里的子类。

|--HashMap     内部结构是哈希表，不是同步的。允许null作为键和值。Set集合里的HashSet是HashMap的一个实例。
    |--LinkedHashMap   链表结构的哈希表，有序的。
|--TreeMap     内部结构是二叉树，不是同步的。可能对Map集合中的键进行排序。他是有序的是，与TreeSet一样。





=======================================================================================================================
java中，只要用到了带有<>的类或者接口，就要明确传入的具体引用数据类型
泛型技术是给编译器使用的技术，用于编译时期，确保了类型的安全。
运行时，会将泛型去掉，因为生成的class文件中是不带泛型的，这个称为泛型的擦除。
为什么擦除？因为为了兼容运行的类加载器。
泛型的补偿：在运行时，通过获取元素的类型进行转换动作。不用使用者再强制转换。

|--- 泛型类、泛型方法、泛型接口：：：：：：：
将泛型定义在类上，全类通用。
如果想在方法上再定义一个泛型。可以再定义：(泛型必须放在返回值前面，修饰符后面，参与静态方法的泛型定义)
public class Student<T>{
    T stu;
    public <W> void show(W str){}
    public void show1(T str){}
    // 当方法是静态的时，不能访问类上定义的泛型。如果静态方法想用泛型，只能定义在方法上。
    public static <T> void show2(T str){}
}
|-泛型接口：
interface Inter<T>{
    public void show(T t);
}
|-实现泛型接口：
class InterImpl implements Inter<String>{
    public void show(String str){}
}

|- 泛型的通配符：  符号来通配。? 也就是未知类型
如  public static void printCollection(Collection<?> col) {}  传过来的参数可以是任意类型。
这个在 containsAll(Collection <?> c) 方法中用的比较多，因为比较，是用equals，任何类型都有equals方法，字符串也可以和对象进行比较。
还有 removeAll(Collection<?> c) 中也是这样用。他们原理一样，先用equals 找出与后面传过来相同的东西，再操作删除。

|- 泛型的上限：    ? extends E  接收E类型或E的子类型对象。
public static void printCollection(Collection<? extends Person> col) {
    Iterator<? extends Person> it = col.iterator();
    while (it.hasNext()) {
        Person p = it.next();
        System.out.println(p.getName()+"--"+p.getAge());
    }
}
|- 泛型的下限： ? super E     接收E类型或E的父类型，下限。
一般存的时候，用上限，如List集合里有  addAll方法，传一个集合进去，批量添加。那时可以在参数上加个 上限的泛型。
因为这样，取出都是按照上限的类型来运算的，不会出现类型安全隐患。

// ---------------------------------------------------------------------------------------------------------
集合 大家庭：
|-Collection
  |-List
    |-ArrayList
    |-LinkedList
  |-Set
    |-HashSet
      |-LinkedHashSet
    |-TreeSet
|-Map
  |-HashMap
    |-LinkedHashMap
  |-TreeMap

集合的一些技巧：
需要唯一吗？
 |-需要  找set
   |-需要顺序吗？
     |-需要  找TreeSet
     |-不需要  HashSet
      但是想要一个和存储一致的顺序（有序）：LinkedHashSet
 |-不需要  找List
   |需要频繁增删吗？
     |-需要：LinkedList
     |-不需要：ArrayList

如何记录每一个容器的结构和所属体系？  看名字
List
  |-ArrayList
  |-LinkedList
Set
  |-HashSet
  |-TreeSet
后缀名就是该集合所属的体系。前缀名就是该集合的数据结构。

看到array，就要想到数组，就要想到查询快，有角标。
看到link，就要想到链表，就想想到增删快，就想想到add get remove等 + first last的方法。
看到hash，就要想到哈希表，就要想到唯一性，就要想到元素需要覆盖hashCode方法和equals方法。
看么tree，就要想到二叉树，就要想到排序，就要想到两个接口Comparable,Comparator。
而且通常这些常用的集合都是不同步的，线程不安全的，效率高。

排序和有序的区别：
如LinkedHashSet 是有序，怎么存进去怎么取出来。
而TreeSet是排序，他还是无序的，只不过按我们指定的顺序给排出来的，并不代表他存的时候就是那个顺序。
如存进去的时候是：
HashMap map = new HashMap();
map.put(7, "a");
map.put(1, "b");
输出的时候是1，7输出，这代表是无序的，只不过结果里是按key的大小来排列的。
HashMap map = new LinkedHashMap();
再执行上面的put方法，得出的结果是  7,1，这是有序的，怎么存进去怎么取出来。



=======================================================================================================================
工具类：Collections、Arrays
Collections.sort(list);  //把list里的元素按自然顺序 进行升序排序
Collections.sort(list, Comparator c);  // 按指定的 比较器 进行排序
Collections.swap(list, int i, int j);  //把list的i和j位置交换元素
Collections.binarySearch(list, 元素);   //使用二分法折半查找，这个要求先用sort排序完再找。返回索引号
Collections.max(list) 和 Collections.max(list)  取集合的最大 最小值
Collections.reverseOrder()    // 返回逆序构造器，可直接用于构造方法中作为参数传进去。
  以前在创建TreeSet的时候，需要强制的有比较器（要么new的时候传比较器进去，要么添加的元素所在的类自己实现了Comparable接口）。这个方法就不用那么麻烦，
  在TreeSet new的时候，构造方法里，传这个 进去。如 TreeSet ts = new TreeSet(Collections.reverseOrder());
  所有的集合都可以用他   如  Collections.sort(list, Collections.reverseOrder()); 这是指定逆序来排列
Collections.reverseOrder(已有的比较器)    // 把已有的比较器的结果进行逆转。
Collections.reverse(list)     //对结果进行反转。
Collections.replaceAll(list, oldVal, newVal)   // 旧元素替换为新元素
Collections.fill(list, val)   // 把list里的所有元素都换成 val这个元素
Collections.shuffle(list)   // 随机洗牌随机排序
Collections.synchronizedCollection(collection)   // 返回同步的线程安全的collection
Collections.synchronizedList(list)   // 返回同步的线程安全的List
Collections.synchronizedMap(map)  // 返回线程安全的Map
Collections.synchronizedMap(Set)  // 返回线程安全的Set
Collections.toArray()      // 集合转为数组，会返回Object类型的数组。还有一个带参数的toArray方法，那返回 参数中 指定类型的数组。如 Collections.toArray(new String[2]);
                              集合变数组后，不允许增删，长度不能变。如果不想别人对你的数字进行增删，那就返回一个数组给别人。
                              toArray方法需要传入一个指定类型的数组的时候：长度如何定义？
                              如果长度小于集合的size，那么该方法会创建一个同类型并和集合相同的数组。
                              如果长度大于集合的size，那么该方法会使用指定长度的数组，存储集合中的元素，其他位置默认为null
                              所以建议，长度就指定为集合的size。如：
                              Collections.toArray(list, new String[list.size()]);



Arrays.binarySearch(arr, key)    //二分查找
Arrays.copyOf()   // 复制
Arrays.copyOfRange(arr, int form, int to)  // 复制指定的位置长度到指定的新数组
Arrays.equals(arr1, arr2)   // 两数组是否相等
Arrays.deepEquals(arr1, arr2)   // 数组比较，不仅比较内容，还进行深度的比较
Arrays.fill(arr, key)   // 替换所有元素
Arrays.hashCode(arr)   // 算指定数组的哈希值
Arrays.sort(arr)    // 排序
Arrays.toString(arr)    // 转为字符串，用于打印，因为如果直接打印数组，是出来哈希值，调用这个方法就会出现字符串。
Arrays.asList(arr)   // 把数组转为List集合，好处就是可以用集合的方法操作数组。注意数组的长度是固定的，用集合的方法不能改变他的长度，比如不能add/clear/remove
                        如果数组中的元素是对象，asList会将数组中的元素转为集合中的元素存储
                        如果数组中的元素是基本数据类型，如int，那么会将数组作为集合中的元素进行存储。所以这个数值数组是一个整体，转成集合后，集合里只有一个元素，就是数值数组。



########################################################################################################
###################### jdk1.5 高级特性
########################################################################################################
|- 增强型 for 适合迭代器操作：（它只适合遍历 数组 或 单列集合，不能遍历Map这样的双列集合，但是可以遍历Map里的keySet和EntrySet）
Iterator it = list2.iterator();
while (it.hasNext()) {
    System.out.println(it.next());
}
等价于：
// 高级for只用于遍历和迭代，不会对元素进行过多的操作。
for (String s:list2){
    System.out.println(s);
}

// 高级for  遍历Map里的keySet和EntrySet
Map<String, String> map = new HashMap<>();
for (String key:map.keySet()){
    System.out.println(key+"--"+map.get(key));
}
for (Map.Entry<String, String> en:map.entrySet()){
    System.out.println(en.getKey()+"--"+en.getValue());
}

|- 可变参数：  必须定义在参数列表的结尾处，而且只能用一个可变参数
public static void method1(String... arr){
    System.out.println(Arrays.toString(arr));
}
method1();
method1("abc1", "abc12", "abcd3");

|- 静态导入
如： 使用工具类 Collections和Arrays。每次用的时候，都是都需要写这两个单词。
import static java.util.Collections.sort;
导入这个，注意需要是静态的 static
以后再书写就只需要写   sort(list);了，不就用  Collections.sort(list);
import static java.util.Collections.*;  // Collections包里的所有的都静态导入



########################################################################################################
###################### 其他对象、Api、工具
########################################################################################################
|- System(java.lang包下)  它是final类型的类，不允许被实例化，里面的方法和属性都是静态的。以下三个是它的字段
  |- System.out  输出流
  |- System.in   输入流
  |- System.err  错误输出流
常用方法：
long System.currentTimeMillis()   // 毫秒数，相对于1970年1月1日
System.getProperties()  //获取当前系统的属性信息，返回Properties集合[继承自HashTable,也就是Map的子类]
  |- Properties集合中存储的都是String类型的键值对，最好使用他自己的存储和取出方法来完成元素的操作。
     有方法 |- setProperty(String key, String value);  设置键值
           |- stringPropertyNames()   返回此集合中的键集。
           |- getProperty(String key)  获取值

代码展示 Properties集合
// Properties集合，继承自HashTable，继承自Map双列集合
Properties pro = System.getProperties();
// 获取里面所有的key
Set<String> keySet = pro.stringPropertyNames();
for (String str : keySet) {
    // 根据key找value
    System.out.println(str+"："+pro.getProperty(str));
}

### 好用的地方：比如在windows下和linux下，换行符不一样，windows是 \n，linux是 \r
所以可以今后写换行的地方，这样写：
System.out.println("Hello"+System.getProperty("line.separator")+"world");
也可以把它抽出来放在静态常量里：
private static final String LINE_SEPARATOR = System.getProperty("line.separator");
System.getProperties() 这里可以获取当前项目的classpath，是在当前项目的bin目录下。
System.setProperty("myclasspath", "/wordcount/input/bin");   设置自己的属性到系统属性中。这些信息是全局的，其他程序都可以使用。


|- Runtime 运行时类，通过 getRuntime()来获取当前运行时对象。它是单例的。
这个类没有构造方法，说明它不能创建对象。又有非静态方法，说明该类提供了静态的返回该类对象的方法。
而且只有一个方法，说明Runtime类使用了单例设计模式。

## 实例化 Runtime是java.lang包下的
Runtime r = Runtime.getRuntime();
## 调用本地程序  如打开记事本，返回Process 进程号，返回Process类。
r.exec("notepad.exe");
// 运行记事本，并解析一个文件。如打开播放器，加空格指定影片的位置，会打开播放器的同时播放那个电影。
Process p = r.exec("notepad.exe C:\\sys001.log");
Thread.sleep(5000);
// 杀掉这个进程，只能杀自己开的，非自己开的不能杀
p.destroy();

|- Math (java.lang包下) 数学类
常量：：：
Math.PI    3.1415926
方法：：：
Math.ceil(12.56);  返回大于参数的最小整数
Math.floor()   返回小于参数的最大整数
Math.round()   四舍五入后的整数
Math.max(3, 4)  返回比较的大值
Math.pow(a, b)  返回第a的b次方。
Math.random()   返回0(包含0)，到1(不包含)之间的小数，如0.4323432333356
想生成1到10的整数： 两种方法
double d = Math.ceil(Math.random()*10);
double d1 = (int)(Math.random()*10+1);
通过Random类来随机：：
Random r = new Random();
r.nextInt(10);   返回最多为10，不包括10，的整数。包括0，最小为0


|- Date 日期(java.util.Date包)
日期对象初始化：
两个构造方法，一个是带参数的，一个是不带参数的。
带参数是毫秒值，返回那个时间的日期。不带参数是当前时间的日期。

毫秒值 转为 日期对象：
1、通过Date对象的构造方法  new Date(timeMillis);
2、通过Date对象的方法设置  date1.setTime(timeMillis);
可以通过Date对象的方法对该日期中的各个字段如年月日等进行操作。

日期对象 转为 毫秒值：【可以通过具体的数值进行运算 如 加10000毫秒】
1、date1.getTime() 方法

其他方法：
date1.compareTo(Date date2)  // 比较两日期，返回int类型，与String等比较一致
date1.equals(Date date2)     // 两日期是否相等
date1.toString()     把日期按这种格式显示  星期几 几月 几号 时分秒 时区 年

|- 日期格式化：  SimpleDateFormat (java.text.SimpleDateFormat 包)
它是 DateFormat的子类。下面这两种方式是 用 DateFormat来格式化：
DateFormat df = DateFormat.getDateInstance(DateFormat.LONG);
System.out.println(df.format(date2));
DateFormat df1 = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG);
System.out.println(df1.format(date2));

这样很麻烦，他提供了 SimpleDateFormat子类：：：
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
String date_str = sdf.format(date2);  // 转为指定格式的字符串了
Date date3 = sdf.parse(date_str);     // 把指定格式的字符串 转为日期

|- Calendar 日历类 (java.util.Calendar 工具包)
创建日历类：
Calendar cal = Calendar.getInstance();

// 设置年
cal.set(Calendar.YEAR, 2019);

// 加两年,减2年是 -2
cal.add(Calendar.YEAR, 2);
cal.add(Calendar.DAY_OF_MONTH, -2);  // 减两天

// 获取年月日星期
int year = cal.get(Calendar.YEAR);
int month = cal.get(Calendar.MONTH)+1; // 这样获取会比当前真正月小1，需要加1
int day = cal.get(Calendar.DAY_OF_MONTH);
int week = cal.get(Calendar.DAY_OF_WEEK); // 老外的星期日是1，星期一是2

// 获取当前是第多少周
cal.getWeeksInWeekYear()




########################################################################################################
###################### IO (Input Output) 流
########################################################################################################
|-输入流和输出流：：：
输入流和输出流是相对于内存设备而言，将外设中的数据读取到内存中，就是输入(读)；
将内存中的数据写入到外设中，就是输出(写)。
硬盘的数据放到内存中计算，是输入，输入就是读。
内存中的数据写到到硬盘中，是输出，输出就是写。

|-按操作数据类型不同  分两类：
字节流     // 计算机里的一切都是字节，字节流 可以处理一切数据
字符流     // 知识：编码表：美国ascii码表,中国GB2312 GBK,国际组织unicode码表。
字符流的由来，就是 字节流 读取文字字节数据后，不直接操作，而是先查指定的编码表，获取对应的文字。
再对这个文字进行操作，简单的说：就是   字节流 + 编码表

|-四个顶层基类
字节流的2个顶层抽象基类   1、InputStream        2、OutputStream
字符流的2个顶层抽象基类   1、Reader(读、输入)    2、Writer(写、输出)
这些体系的子类都是以父类名作为后缀。而且子类名的前缀就是该对象的功能。

如果要操作文字数据，建议优先考虑字符流。
而且将数据从内存写到硬盘上，要使用字符流中的输出流 Writer
硬盘的数据基本体现是文件，希望找到一个可操作文件的Writer。就是FileWriter。

|- FileWriter 写文件
private static final String LINE_SEPARATOR = System.getProperty("line.separator");
/*
创建一个可以往文件中写入字符数据的字符输出流对象
既然是往一个文件中写入文字数据，那么在创建对象时，就必须明确该文件(用于存储数据的目的地)
如果文件不存在，则会自动创建。
如果文件存在，则会被覆盖，也就是先删掉再创建。
构造函数里可以指定第二个参数，是否追加写入，默认是覆盖。
* */
FileWriter fw = new FileWriter("demo1.txt", true);
// 调用 write 方法 ，数据会被临时存储，写入到了临时存储缓冲区中。
fw.write("sf"+LINE_SEPARATOR+"sbbb");
// 进行刷新，将数据从缓冲区 写到目的地中。
//fw.flush();
// 关闭流关闭资源，关闭之前，会自动调用flush()
fw.close();

|-FileReader 读取文件
/**
 创建读取字符数据的流对象。
 在创建读取流对象时，必须要明确被读取的文件。一定要确定该文件是存在的
 用一个读取流 关联一个已存在的文件。
 读文件的过程：本质上是一次读一个字符，只不过用char[] buf = new char[1024]，
 是把一次读一个字符，先放在这个数组里，等这个数组满1024，或者读到 -1 代表读完了。
 再把这个char[] 字符数组转为 字符串。完成读取过程。
 read方法，不带参数是一次取一个字符。如果带参数是指一次读取一个字符数组的字符。(本质也是一个一个读)
 */
FileReader fr = new FileReader("demo1.txt");
// 使用read(char[])读取文本文件数据，一般这数字就是1024，因为存储时就是按这大小来存的。
char[] buf = new char[1024];
// 将读到的字符存储到数组中，返回读取到的字符数量。
int len = 0;
while ((len = fr.read(buf)) != -1){
    System.out.println(new String(buf, 0, len));
}

|-复制文件
// 练习：复制c盘的文本文件到d盘
// 思路就是先读取出源文件，再写入到目标文件。既然是操作文本文件，使用字符流
// 读数据
FileReader fr = new FileReader("c:\\sys001.log");
// 写数据
FileWriter fw = new FileWriter("c:\\sys001_copy.log");
// 创建一个临时容器，用于缓存读取到的字符。
char[] buf = new char[1024];
// 定义一个变量记录读取到的字符数，其实就是往上面那个数组里装的字符个数，他大小是1024，可能本次只装了20
int len = 0;
while ((len = fr.read(buf)) != -1) {
    // 这个得只能写0到len，不然会把1024这个字符数组都写进去了，很多空格。
    fw.write(buf, 0, len);
}
// 关闭流
fw.close();
fr.close();

|-缓冲区：java提供了两个缓冲区，缓冲读java.io.BufferedReader  缓冲写java.io.BufferedWriter
缓冲区就是对要操作的内容进行临时缓存，提高效率。
他里面有个好方法： 对象.newLine();   写入一个换行符，适应不同平台。

缓冲 BufferedWriter 代码
----------------------------------------------------------------------------
FileWriter fw = new FileWriter("buf.txt");
// 为了提高写入的效率使用字符流的缓冲区。
// 创建一个字符写入流的缓冲区对象，并和指定要被缓冲的流对象相关联
BufferedWriter bw = new BufferedWriter(fw);
// 使用缓冲区的写入方法，他的方法与Writer完全相同
bw.write("abc");
bw.newLine();
bw.write("def");
// 使用缓冲区的刷新方法将数据刷新到目的地。一定要刷新，write一次刷新一次。
bw.flush();
// 关闭缓冲区，其实关闭的就是缓冲的流对象。关了缓冲区以后，文件的流也就关闭了。
bw.close();


缓冲 BufferedReader 代码
----------------------------------------------------------------------------
文本类型的流特有的：可以一次读取一行。（根据回车符判断是否换行）。里面提供了 readLine() 方法。
FileReader fr = new FileReader("buf.txt");
BufferedReader br = new BufferedReader(fr);
String line = null;
// 最后一行，如果不存在，返回null
while ((line = br.readLine()) != null){
    System.out.println(line);
}
br.close();
BufferedReader 的 read()方法，是从缓冲区里读，覆盖了他父类的read()方法，他父类是从硬盘上取。
这个read()方法很高效。也可以传一个字符数组参数进去一次读到字符数组中。
readLine()取的数据，是取一行，他的原理与read()一样，一个一个读，只不过读到换行符就终止并返回，
返回的只是字符数据，不包括换行符。如读完了，则返回null。


NumberLineReader(用到行号时才用他)  是BufferedReader 的子类，也是装饰，他增加的功能就是 能获取和设置 当前的行号。
----------------------------------------------------------------------------
FileReader fr = new FileReader("buf.txt");
LineNumberReader br = new LineNumberReader(fr);
// 设置行号从哪开始
br.setLineNumber(100);
String line = null;
while ((line = br.readLine()) != null) {
    System.out.println(br.getLineNumber()+":"+line); // 获取行号
}


装饰设计模式：   外观改变，本质实际没改变。
----------------------------------------------------------------------------
设计模式是用来解决问题的。
它是对一组对象的功能进行增强时，就可以使用该模式进行问题的解决。下面的NewPerson就是对Person的增强，装饰。
其实上面的 输入输出流和他们的缓冲区，缓冲区就是对输入输出流的 装饰。
public class PersonDemo {

    public static void main(String[] args) {
        Person p = new Person();
        NewPerson np = new NewPerson(p);
        np.eat();
    }

}

class Person{
    void eat(){
        System.out.println("吃饭");
    }
}

class NewPerson{
    Person p;
    NewPerson(Person p) {
        this.p = p;
    }

    void eat(){
        System.out.println("甜点");
        p.eat();
        System.out.println("水果");
    }
}
继承也能达到这种效果，为啥不用继承？要用装饰呢？因为装饰更灵活，因为他可以对一组(如父类)进行增强。而继承只能继承具体的一个类，
有一个类要增加就继承他一下，但是一组的怎么解决？他又不能继承父类，继承父类，那子类就用不上。而装饰可以。

装饰比继承灵活。
装饰类和被装饰类 都必须所属于同一接口或父类。被装饰类可以是那个父类，一装饰，本父类下的所有类都能用。


----------------------------------------------------------------------------
字节流 byte
----------------------------------------------------------------------------
----------------------------------------------------------------------------
字符流的缓冲区的数组是 char 字符。对一个中文字，字符流一次就能读出来。而字节流需要2次才能读出来。
字节流的缓冲区的数组是 字节 byte

|- 输出流（内存到硬盘，也就是写数据）
----------------------------------------------------------------------------
// 创建字节输出流对象，用于操作文件
FileOutputStream fs = new FileOutputStream("bytestream.txt");
// 写数据，直接写入到了目的地中，所以不需要flush也就是不需要缓冲。缓冲区Buffer才会用到flush方法。
fs.write("abc".getBytes());
// 需要完成资源关闭
fs.close();

|-输入流（硬盘到内存，也就是读数据）
----------------------------------------------------------------------------
// 创建读取流对象，和指定文件关联。
FileInputStream fs = new FileInputStream("bytestream.txt");
// 这叫自定义缓冲区   一次读取一个缓冲区数组大小的数组
byte[] buf = new byte[1024];
int len;
while ((len = fs.read(buf)) != -1){
    System.out.println(new String(buf, 0, len));
}

另外一种方式，主要是用到了他里面的 获取文件字节大小的方法 available()
// 输出流的新读取方式
// 获取文件的字节数(英文只占一个字节，中文占两个)  fs.available()
byte[] buf = new byte[fs.available()];
fs.read(buf);
System.out.println(new String(buf));

fs.close();


|- 输出流 缓冲区
// 创建字节输出流对象，用于操作文件
FileOutputStream fs = new FileOutputStream("bytestream2.txt");
BufferedOutputStream bs = new BufferedOutputStream(fs);
// 写数据，直接写入到了目的地中，所以不需要flush也就是不需要缓冲。缓冲区Buffer才会用到flush方法。
bs.write("abc".getBytes());
// 缓冲区需要flush
bs.flush();
// 关闭缓冲区
bs.close();



键盘输入输出：
----------------------------------------------------------------------------
键盘本身就是一个标准的输入设备，java对于这种输入设备都有对应的对象。在System类(java.lang)中。
InputStream in = System.in;
这个 in 最好不要close，因为他是随着系统消失而消失，随着系统来而来。
默认的输入输出设备都不需要关。如键盘和控制台。

StringBuffer和StringBuilder是两个字符串容器。
OutputStream os = System.out; //实际上他是 PrintStream类。
System.in 和 System.out 都是字节流。要输出为文本，都需要转换器转换成字符流。

键盘录入代码：
----------------------------------------------------------------------------
// 字节流
InputStream is = System.in;
int ch = 0;
while ((ch = is.read()) != -1) {
    System.out.println(ch + "--" + (char) ch);
}
// 这个标准输入输出流不需要关闭，会随着系统关而关，它只有一个，关了就没了。
//is.close();


把字节流 转为 字符流：
----------------------------------------------------------------------------
练习：键盘输入字符，回车后转为大写，当输入了over以后，结束输入:

// 字节输入流
InputStream is = System.in;
// 字节流转为字符流的转换器，他是字符流的子类，也是装饰类
// 如果是中文，占两个字节，所以如果直接用System.in输入中文一个字，会返回两个字符。
// 而通过字符流输入一个中文汉字，他会去编码表里查表，查到后返回一个字符编码。
InputStreamReader ir = new InputStreamReader(is);
// 缓冲区
BufferedReader br = new BufferedReader(ir);
String line = null;
while ((line = br.readLine()) != null) {
    if ("over".equals(line)) {
        break;
    }
    System.out.println(line.toUpperCase());
}


// 字节输出流 转为 字符输出流
// 字符转字节
InputStream is = System.in;
// 字节流转为字符流的转换器
InputStreamReader ir = new InputStreamReader(is);
// 输入缓冲区
BufferedReader br = new BufferedReader(ir);

// 输出 字节流，输出到标准控制台。
OutputStream os = System.out;
// 这是为了把 最终显示到控制台的 字节流 转字符流。
// 之前学过的FileWriter 是这个转换流的子类。所以写文件的时候不需要再转换一次，字节直接就以字符的方式写到文件了。
OutputStreamWriter ow = new OutputStreamWriter(os);
// 输出缓冲区
BufferedWriter bw = new BufferedWriter(ow);

String line = null;
while ((line = br.readLine()) != null) {
    if ("over".equals(line)) {
        break;
    }
    bw.write(line.toUpperCase());
    bw.newLine();
    // 刷新才会显示出来
    bw.flush();
}


简化代码  上面那么多行，省成下面这几行：
----------------------------------------------------------------------------
BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));
BufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(System.out));
// 如果想不写到控制台，而是输出到文件中，只要修改上面那一行代码：BufferedWriter bufw = new BufferedWriter(new FileWriter("abc.txt"));
//或者：BufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream("abc.txt")));
// 如果想从文本文件读内容写到控制台： 改一行  BufferedReader bufr = new BufferedReader(new InputStreamReader(new FileInputStream("abc.txt")));

String line = null;
while ((line = bufr.readLine()) != null) {
    if ("over".equals(line)) {
        break;
    }
    bufw.write(line.toUpperCase());
    bufw.newLine();
    // 刷新才会显示出来
    bufw.flush();
}

转换流：
----------------------------------------------------------------------------
InputStreamReader  字节到字符的桥梁，解码
OutputStreamWriter  字符到字节的桥梁，编码。
流的操作规律：
之所以要弄清楚这个规律，是因为流对象太多，开发时不知道用哪个对象合适。
想要知道开发时用到哪些对象，只要通过四个明确即可：
1、明确源和目的(汇)
    源：InputStream   Reader
    目的：OutputStream   Writer
2、明确数据是否是纯文本数据。
    源：是纯文本：Reader   否：InputStream
    目的：是纯文本：Writer   否：OutputStream
    到这里就可以明确需求中具体要用哪个体系。
3、明确具体的设备：
    源设备：
        硬盘：File
        键盘：System.in
        内存：数组
        网络：Socket流
    目的设备：
        硬盘：File
        控制台：System.out
        内存：数组
        网络：Socket流
4、是否需要其他额外功能。
    4.1、是否需要高效（缓冲区）：加Buffer
    4.2、转换。(字节流转字符流，字符流转字节流)


字符编码的问题：
----------------------------------------------------------------------------
java中字符用unicode码，中文用gbk码。全世界通用，两个字节表示全世界的文字。
如果是a,b这种字符，会在他前面加上 8个0，最后是全世界两位。
由于2个字节来装，太占空间了，后来产生了utf-8编码，有几个就占几个。

直接操作 FileWriter,FileReader就有缺陷，他们不能指定编码，只能用操作系统默认的编码如gbk。
所以需要转换器，OutputStreamWriter, InputStreamReader。他们可以指定编码。
他们的构造函数里 第二个参数可以指定编码。
字符流 FileWriter和 FileReader 其实，是对 转换器 进行了一层封装，也就是说：
new FileWriter("a.txt")  <===>   new OutputStreamWriter(new FileOutputStream("a.txt"));
这两个等价。

但是 后者可以指定编码：
new OutputStreamWriter(new FileOutputStream("a.txt"), "utf-8");
用utf-8以后，文件的大小就会节省。一个文件他的大小，就是这个字符数来算的，如有10个英文字符，他的大小就是10个字节。
字符流那Reader类FileReader，可以用char[] 来read()。
字节流那Reader类FileIntream，只能用byte[] 来read()。

什么时候使用转换流：？
1、源或目的对应的设备是字节流，但是操作的却是文本数据，可以使用转换作为桥梁，提高对文本操作的便捷。
2、一旦操作文本涉及到具体的指定编码表时，必须使用转换流。



----------------------------------------------------------------------------
------------ File  (java.io.File包)
----------------------------------------------------------------------------
可以将一个已存在的，或者不存在的文件或目录封装成file对象。
创建流的时候，可以直接传一个File对象进去。如 FileReader fr = new FileReader(new File("abc.txt"));
这样的话，如果先读后写的时候，可以都共用同一个对象，而且还可以判断如果这个文件不存在先创建他。

|-构造函数
File file = new File("abc.txt");
File file1 = new File("c:\\","abc.txt");
File file2 = new File("c:\\");
File file3 = new File(file2, "abc.txt");

|-字段
// 路径分隔符 File.pathSeparator，如 unix是: windows是; 主要是在环境变量里用。
// 文件分隔符 File.separator
System.out.println(File.separator);
System.out.println(File.pathSeparator);

|-常见方法：
1、获取
    1.1获取文件名称   file.getName()
    1.2获取文件路径   file.getAbsolutePath()绝对路径   file.getPath()相对路径
    1.3获取文件大小   file.length()字节数   file.getFreeSpace()剩余空间
    1.4获取文件修改时间   file.lastModified() 返回毫秒数
    1.5获取父路径     file.getParent()  这个得要绝对路径创建的File才能获取到，不然返回null

2、创建与删除
    File file = new File("abc.txt");
    boolean b = file.createNewFile();
    如果已经存在，则不会再创建。和输出流不一样，输出流是如果存在则覆盖，除非指定第二个参数，指定追加。
    已存在或创建失败，则返回false，成功返回true
    ##创建目录：
    File file1 = new File("abc");
    file1.mkdir();
    ##创建多级目录：
    file1 = new File("abc\\a\\b\\c");
    file1.mkdirs();

    删除：
    file.delete();  删除成功返回true，失败false。如果文件正被流操作，也是删除不掉。
    file.deleteOnExit();  退出时删除，程序结束删除。
    file1.delete(); 删除目录，如果目录里有文件，则删除失败
    对于如果file1是 "a/b/c/d"这种多级目录，执行删除只会删最后一级。

3、判断
    文件是否存在  file.exists();
    是否是文件    file.isFile()
    是否是目录    file.isDirectory()
    是否隐藏      file.isHidden()

4、重命名
    如果路径不在一个地方，则是重命名并且移动位置到参数里指定的位置
    File file1 = new File("abc.txt");
    file.renameTo(new File("abc2.txt"));

5、listRoots  静态方法  列出所有盘符。
   File.listRoots();  得到c:\   d:\   这方法会返回File[] 文件数组，遍历出来即可。

6、空间：
    可用空间  file.getFreeSpace() 如果file是具体某个文件，这里也是返回此文件所在的盘符的可用空间
    总容量    file.getTotalSpace()
    可以给虚拟机用的空间 与 可用空间一样的数  file.getUsableSpace()

7、String[] list() 方法，返回File类当前目录下的所有文件包括文件和目录还有系统隐藏文件。
    要用list()方法，File对象中封装的必须是目录。
    如果是系统目录或隐藏目录，也会返回空。如果 file1.isHidden() 则不需要去访问。
7.1、list()方法有个重载方法：可以传个过滤器进去，过滤些自己需要的文件。比如只要.java文件。
    过滤器是个接口，FilenameFilter接口，需要实现。
    可以传个匿名类进去：
    String[] lists = file.list(new FilenameFilter() {
        @Override
        public boolean accept(File dir, String name) {
            return name.endsWith(".java");
        }
    });
7.2、listFiles() 方法  获取目录下的所有文件和目录，返回File对象。
    上面的list()方法只是返回文件名，如果想过滤隐藏文件，list()方法就不太好用了。
    需要一个返回指定目录下所有文件对象的方法：     listFiles();
    想过滤的话 过滤器接口是 FileFilter。
    File file1 = new File("d:\\");
    File[] files = file.listFiles(new FileFilter() {
        @Override
        public boolean accept(File pathname) {
            return !pathname.isHidden();
        }
    });
    for (File f : files){
        System.out.println(f);
    }

练习：深度遍历
----------------------------------------------------------------------------
// 递归遍历某目录下的所有文件和目录，以及目录里的子目录
private static void listAll(File dir) {
    File[] files = dir.listFiles();
    for (File f : files) {
        System.out.println(f);
        if (f.isDirectory()){
            listAll(f);
        }
    }
}

递归：
----------------------------------------------------------------------------
递归是函数自身直接或间接调用了自身。
一个功能被重复使用，并每次使用时，参与运算的结果和上一次调用有关，这时可以用递归来解决问题。
注意：：
递归一定要注意条件，否则容易 栈内存溢出。
还要注意递归的次数，因为次数多了，光进没有出，也容易 栈内存溢出。


Properties 集合 (java.util.Properties)
----------------------------------------------------------------------------
|------------- Map常用的子类：
|--HashTable   内部结构是哈希表，是同步的，因为jdk1.0就有了，不支持Null作为键和值。
    |--Properties
特点：
1、该集合中的键和值都是字符串类型
2、集合中的数据可以保存到流中，或者从流中获取。
通常该集合用于操作以键值对形式存在的配置文件，由于这点，它被广泛使用。
Properties是存配置信息，与它对应的是xml文件。还有一种是数据库。

方法：
setProperty(String key, String value)
getProperty(String key)
getProperty(String key, String defaultValue), 获取key对应的value，如果没有则用那默认值
stringPropertyNames()  返回所有键Set，相当于keySet
list(PrintStream out)           // 将属性列表输出到指定的输出流，一般调试时用。
store(Writer out, String comments)   //保存数据，把内存中的属性数据写入输出流如文件中，第二个参数是用来做描述的。
                                       配置文件是存在于内存中，内存一旦释放就全没了，想把它里面的内容保存到硬盘上，这就是持久化。
                                       comments是注释，会加到这个文件的第一行。
load(Reader in)   // 从流文件中加载数据到内存中
load(InputStream is) // 从流文件中加载数据到内存中

示例：
Properties prop = new Properties();
prop.setProperty("ght", "35");
prop.getProperty("ght");
// 取所有数据
Set<String> names = prop.stringPropertyNames();
for (String str : names) {
    System.out.println(str + "-" + prop.getProperty(str));
}
// 用于调试用，将属性列表输出到指定的输出流，下面这个是输出到控制台
prop.list(System.out);
// 配置文件输出到流
prop.store(new FileWriter("abc.txt"), "name+age");
prop.store(new FileOutputStream("abc.txt"), "name+age");

// 从流文件中读出配置文件，放在 属性集合里。load方法
prop.load(new FileReader("abc.txt"));
prop.load(new FileInputStream("abc.txt"));


练习：读配置文件，修改里面的数据，并保存
----------------------------------------------------------------------------
File file = new File("abc.properties");
if (!file.exists()){
    file.createNewFile();
}
FileReader fr = new FileReader(file);
Properties prop = new Properties();
prop.load(fr);
prop.setProperty("abc2", "100");

FileWriter fw = new FileWriter(file);
prop.store(fw, "love");
fr.close();
fw.close();





----------------------------------------------------------------------------
----------------------------------------------------------------------------
------------打印流 是可以直接操作输入流的       只负责目的地
----------------------------------------------------------------------------
----------------------------------------------------------------------------

PrintStream  打印流 (java.io.PrintStream)  它是OutputStream的子类。操作字节
----------------------------------------------------------------------------
优势：
1、提供了打印方法可以对多种数据值进行打印。并保持数据的表示形式。
2、它不抛IOException

构造函数：接收三种类型的值：
1、字符串路径
2、File对象
3、字节输出流。

PrintStream out = new PrintStream("print1.txt");
// write方法只写最低8位，整数在内存中是占4个字节，他就是4组8位数组成，这里只取最后8位，
// 所以导致如果write(610) 会把b写进去，因为他除最后8位之外的都被忽略了。
// 把97对应的 Accis码 a 写入到文件中。
// 如果write想原样写入 97，可以 out.write((97+"sb").getBytes()) 写入字节进去。
out.write(97);
out.print(97); // 将97先变成字符 保持原样将数据打印到目的地。
out.close();


PrintWriter  打印流 (java.io.PrintWriter)  它是 java.io.Writer 类的的子类。操作字符
----------------------------------------------------------------------------
tomcat往网页输出，就是用的这个类。
构造函数参数：
1、字符串路径
2、File对象
3、字节输出流   构造方法可以传第二个参数 true，代表自动刷新
4、字符输出流

BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
PrintWriter out = new PrintWriter(System.out, true);
// 第二个参数是指定是否需要自动刷新，如果自动刷新，下面不需要再写out.flush()
out = new PrintWriter(new FileWriter("abc.txt"), true);
String line = null;
while ((line = br.readLine()) != null) {
    if ("over".equals(line))
        break;

    out.println(line.toUpperCase()); // println 会自动换行，相当于原来的 newLine();而且newLine还需要输入流缓冲才能有这方法
    // 构造方法里如果是true，这行可以注释掉。
    //out.flush();
}
out.close();
br.close();




----------------------------------------------------------------------------
----------------------------------------------------------------------------
------------序列流 SequenceInputStream      只负责源 它们是InputStream的子类
----------------------------------------------------------------------------
----------------------------------------------------------------------------
它是对多个流进行合并。是表示其他输入流的逻辑串联。
需要字节的方式操作，因为他不仅可以合并文本，还可以合并媒体文件。

Vector<FileInputStream> v = new Vector<>();
v.add(new FileInputStream("java.txt"));
v.add(new FileInputStream("abc.txt"));

Enumeration<FileInputStream> en = v.elements();
SequenceInputStream sis = new SequenceInputStream(en);

BufferedOutputStream bs = new BufferedOutputStream(new FileOutputStream("abc1.txt"));
byte[] buf = new byte[1024];
int len = 0;
while ((len = sis.read(buf)) != -1){
    bs.write(buf, 0, len);
}
bs.close();
sis.close();

这里面需要传 Enumeration类型的参数进去，但是操作Enumeration特别麻烦。
我们可以用 迭代器来操作 Iterator。
Iterator 是取代了 Enumeration。
如果上面可以用迭代器，那就不需要用Vector 这种List，太低效了。
可以用ArrayList集合，然后用 工具类：
Enumeration en = Collections.enumeration(list); 转换下即可。

优化后的代码：：
List<FileInputStream> list = new ArrayList();
list.add(new FileInputStream("java.txt"));
list.add(new FileInputStream("abc.txt"));
Enumeration en = Collections.enumeration(list);
SequenceInputStream sis = new SequenceInputStream(en);
其他部分与原来一致。


练习：切片
----------------------------------------------------------------------------
src/main/java/cn/jhsoft/study/iostream/SplitFileDemo.java    把大文件切成小切片
src/main/java/cn/jhsoft/study/iostream/MergeFileDemo.java    把小切片合并成文件



ObjectOutputStream、 ObjectInputStream  对象流  （java.io包下的类）
----------------------------------------------------------------------------
对象的输入输出流，需要那对象 实现序列化接口，implements Serializable(这个称为标记接口)
ObjectOutputStream 对象有 writeObject 方法，写个对象进去
存储对象的文件名  都是   xxx.object
这个是对一些特定的对象使用，比如数据库连接对象等，他的功能仅仅是将内存上的堆内存数据放到硬盘上。
这个不会写静态的变量进去，只会写非静态的。

序列化：
ObjectOutputStream obs = new ObjectOutputStream(new FileOutputStream("abc.object"));
obs.writeObject(new Person("宫涛", 32));
obs.close();

对象反序列化：
ObjectInputStream ois = new ObjectInputStream(new FileInputStream("abc.object"));
Person p = (Person) ois.readObject();
System.out.println(p.getName()+"--"+p.getAge());
ois.close();


ObjectOutputStream、 ObjectInputStream  对象流 的 实体类：bean类：
----------------------------------------------------------------------------
###############################  transient关键字(短暂的瞬间的)  ###############################
如果非静态的变量，不想写进去到硬盘中。可以加 transient 关键词，这个词的意思是 短暂的，瞬间的。
完全不影响对象，只不过写不到硬盘上而已。
class Person{
    private transient String name;
    private static int age;
}



RandomAccessFile   随机访问文件(java.io.RandomAccessFile包)   它的父类是 java.lang.Object
----------------------------------------------------------------------------
它并不是io体系中的子类。它是 java.lang.Object下的。

特点：
1、该对象既能读，又能写。只能操作文件，包括文本文件和媒体文件。
2、该对象内部维护一个byte数组，并通过指针可以操作数组中的元素。
3、可以通过getFilePointer方法获取指针的位置，和通过seek方法设置指针的位置。
4、其实该对象就是将字节输入流和输出流进行了封装。
5、该对象的源或目的只能是文件，通过构造函数就可以看出。
6、构造函数里第一个参数是传File，第二个参数是传个mode，可以选r或者rw，也就是读和读写。
7、如果文件不存在则创建，如果文件存在则不创建，不会覆盖，其他的输出流是覆盖。

 * 随机访问文件，要求数据有规律，也就是自己知道它里面有什么。
 * 如果没规律的，此类不适用。
 * 比如知道里面存的是姓名和年龄，如果是姓名可能是都是两个字，年龄反正是int的都是占4个字节，所以无所谓多大年纪
 * 或者如果想要有规律，可以用16个字节来表示姓名，这样每个人都是16个，不够的用空格补
 * 这样就有规律了，自己就可以算出来指针的位置，可以随机地去读和写了。
 *
 * 如果是有多线程操作同一文件，那这个类就特别适合了，每个线程去写一段。可以实现多个线程同时往一个文件写数据。
 * 断点续传，也是用的它。


代码：：：
写数据：

RandomAccessFile raf = new RandomAccessFile("ab.txt", "rw");
// 往指定位置写入数据
// 如果没有指定位置，又会从0角标开始写数据。新的0角标覆盖原来的0角标，新的1角标覆盖原来的1角标。
// 其它没有覆盖到的位置的数据不会动。
raf.seek(5*13);

raf.write("陈义".getBytes());
raf.writeInt(20);
raf.close();


读数据：
RandomAccessFile raf = new RandomAccessFile("ab.txt", "r");
byte[] buf = new byte[6];   // 取6个字节，也就是中文的二个字
raf.read(buf);
System.out.println(new String(buf));
int age = raf.readInt();   // 取完上面的姓名，指针往下移，取一个整数，也就是再取4个字节，那4个字节里存的就是一个int类型的数据
// 通过seek设置指针的位置，这就叫随机访问，想从哪个位置读就从哪个位置读。
raf.seek(1*10);
// 获取当前指针所在的位置
raf.getFilePointer();
raf.close();


管道流 PipedInputStream 和 PipedOutputStream
----------------------------------------------------------------------------
输入输出可以直接进行连接，通过结合多线程使用。
输出流会一直等，等待输入流里有数据了，就会输出来。不然就一直等，会死锁。所以需要多线程。
代码参见：src\main\java\cn\jhsoft\study\iostream\PipedStreamDemo.java

两个管道(输入输出)相连：：
PipedInputStream pi = new PipedInputStream();
PipedOutputStream po = new PipedOutputStream(pi);
// 上面是通过构造方法来连接两个管道，或者通过connect方法连接两个管道
// po.connect(pi);
new Thread(new Input(pi)).start();
new Thread(new Output(po)).start();



操作基本数据类型的  流  DataInputStream、DataOutputStream
----------------------------------------------------------------------------
它是一个包装类，初始化的时候，还是要传  FileInputStream对象进去。它只是包装原来的 FileInputStream等 类

写数据：：
DataOutputStream dos = new DataOutputStream(new FileOutputStream("utf.txt"));
// utf修改版的，存进去时会自动加标头，别的人解不开，只能用他自己提供的方法去解开
dos.writeUTF("你好");
// 还提供了writeInt等一堆方法。
dos.close();

读数据：：
DataInputStream dis = new DataInputStream(new FileInputStream("utf.txt"));
String str = dis.readUTF();
System.out.println(str);
dis.close();


操作字节数组的  流  ByteArrayInputStream、ByteArrayOutputStream
----------------------------------------------------------------------------
他们都是用来   操作 源 和 目的 都是内存的对象。
操作的是长度可变的数组，从内存中来 到 内存中去。

ByteArrayOutputStream 对象，不需要关闭，关闭也无效，因为他只在内存中操作，不会操作资源。
可以使用 toByteArray()和toString()获取数据。

ByteArrayInputStream 包含一个内部缓冲区，它是操作源的，必须有源，
所以在它初始化的时候，需要传个字节数组进去。

代码：：：
ByteArrayInputStream bis = new ByteArrayInputStream("abcdefa".getBytes());
ByteArrayOutputStream bos = new ByteArrayOutputStream();

int ch = 0;
while ((ch = bis.read()) != -1){
    bos.write(ch);
}
System.out.println(bos.toString());

// 里面还有个writeTo(OutputStream out) 方法，把流写到另外一个输出流里去。
bos.writeTo(new FileOutputStream("s.txt"));

应用：：
如果源是内存的一些操作，可以单用 ByteArrayInputStream
如果目的是内存的一些操作，可以单用 ByteArrayOutputStream



操作字符数组的  流  CharArrayInputStream、CharArrayOutputStream
----------------------------------------------------------------------------
CharArrayReader cr = new CharArrayReader("abcd".toCharArray());
字符串转char数组   toCharArray();


操作字符串的  流  StringReader、StringWriter
----------------------------------------------------------------------------
StringReader sr = new StringReader("test");


编码::
----------------------------------------------------------------------------
String str = "你好";
byte[] buf = str.getBytes("utf-8");  // 编码   得到 -60-29-70-61-31-11，计算机硬盘上实际上存的就是这个，只不过记事本解析出来后，解析成了 中文，是下面这个解码的功劳
String s1 = new String(buf, "utf-8"); // 解码   把 -60-29-70-61-31-11 解成  你好
如果用utf-8编的，然后用错了用 iso8859去解的，会得到一堆 ??，这时再用iso8859去编一次，又会重新得到 -60-29等这样的数字
再用utf-8去解。还是可以解的回来。
但如果上面的换种情况，用gbk编的，用utf-8去解，会解不出来，得到??，utf-8再给他编下码成了 -17-65-67 这代表无效字符。
再用gbk解，是解不出来的。
为什么iso8859可以而utf-8不行，因为iso8859是单字节编码解码的，并且他不识别中文，所以他能还原得回来。
而utf-8他自己加工了一次，再解就解不出来。iso8859是，不做处理。所以最终能解出来。


练习：：中文截取
/**
 * 截取中文字符串
 * @param str  要截取的字符串
 * @param len 截取的长度
 */
private static String testsubstr(String str, int len) throws Exception {
    byte[] buf = str.getBytes("utf-8");

    // 记录想截取的这一段之前 有多少个负数
    int count = 0;
    for (int i = len-1; i >= 0 ; i--) {
        if (buf[i] < 0){
            count ++;
        }
    }

    // 如果负数刚好是3和3的倍数，说明截取的len刚好够中文，所以直接返回相应的长度
    if (count%3 == 0){
        return new String(buf, 0, len, "utf-8");
    }else if (count % 3 == 1){// 如果负数的数量为1个或4个，那就需要返回的结果里减掉1个长度
        return new String(buf, 0, len-1, "utf-8");
    }else{// 如果负数的数量为2个或5个，那就需要返回的结果里减掉2个长度
        return new String(buf, 0, len-2, "utf-8");
    }
}

对于utf8编码，如果是英文和数字的，是占一个字节，那它是以 用0 开头 的8位表示如 0xxxxxxx
对于中文，是3个字节，第一个字节是 1110 xxxx,第二个是 10 xxxxxx， 第三个是 10 xxxxxx
对于其它2个字节的情况，第一个字节是 110 xxxxx,第二个是 10 xxxxxx



----------------------------------------------------------------------------
------------ 网络编程  (java.net包里)
----------------------------------------------------------------------------
类InetAddress，表示互联网IP地址。  InetAddress.getLocalHost() 获取本地主机，返回IP对象。
//获取本地主机IP地址对象
InetAddress ip = InetAddress.getLocalHost();
// 获取其它主机的ip地址对象
ip = InetAddress.getByName("jd.com");
// IP地址
System.out.println(ip.getHostAddress());
// 主机名，会根据ip去解析
System.out.println(ip.getHostName());



DatagramSocket类
----------------------------------------------------------------------------
Socket是网络通信的两端。网络服务端点。网络通信就是Socket通信。
UDP传输：
java.net.DatagramSocket  既然接收也能发送
java.net.DatagramPacket  数据报包。构造方法里，要传 SocketAddress对象的构造方法，都是发送数据。


创建UDP传输的发送端：：
----------------------------------------------------------------------------
思路：
1、建立udp的socket服务。（使用DatagramSocket对象）
2、将要发送的数据封装到数据包（DatagramPacket）中。
3、通过udp的socket服务将数据包发送出去。
4、关闭socket服务。

代码：：
// 1、udp socket服务，使用DatagramSocket对象，
// 如果在这构造方法里写个端口进去，如8888，是代表以这个端口来发送，如果不指定，则随机。
DatagramSocket ds = new DatagramSocket();

// 2、将要发送的数据封装到数据包中。
String str = "udp传输演示：宫海涛";
// 使用DatagramPacket将数据封装到该对象包中。
byte[] buf = str.getBytes();
// ip 如果改为 10.12.128.255代表它是广播地址，ip在 10.12.128.1到 10.12.128.254的人都能接收到，当然是用他们的10000端口来接
InetAddress ip = InetAddress.getByName("10.12.128.161");
DatagramPacket dp = new DatagramPacket(buf, buf.length, ip, 10000);

// 3、通过udp的socket服务将数据包发送出去，使用send方法。
ds.send(dp);

// 4、关闭资源
ds.close();




创建UDP传输的接收端：：
----------------------------------------------------------------------------
思路：
1、建立udp的socket服务。（使用DatagramSocket对象）
2、创建数据包（DatagramPacket），用于存储接收到的数据，方便用数据包对象的方法解析这些数据。
3、使用socket服务的receive方法将接收的数据存储到数据包中
4、通过数据包的方法解析数据包中的数据。
5、关闭资源。

代码：：
// 1 建立udp的socket服务，并指定监控的端口
DatagramSocket ds = new DatagramSocket(10000);

// 2 创建数据包
byte[] buf = new byte[1024];
DatagramPacket dp = new DatagramPacket(buf, buf.length);

// 3,使用接收方法将数据存储到数据包中
ds.receive(dp); // 阻塞式的

// 4,通过数据包对象的方法，解析其中的数据，比如，地址，端口，数据内容
String ip = dp.getAddress().getHostAddress();// 发送端的地址
int port = dp.getPort();// 不是本服务端的端口，是发送端的端口
// dp.getLength()是数据包数据的长度，数据包自己知道
String content = new String(dp.getData(), 0, dp.getLength());
System.out.println(ip+":"+port+":"+content);

// 5,关闭资源
ds.close();



UDP练习：：：：
----------------------------------------------------------------------------
群聊聊天室：用多线程处理。代码如下：
src\main\java\cn\jhsoft\study\net\ChatDemo.java




TCP Socket类
--------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------
分两个类 不像UDP里的DatagramSocket既然接收也能发送，也就是既然是客户端用也能服务端用。
Socket类是客户端套接字   java.net.Socket
ServerSocket类是服务端套接字  java.net.ServerSocket


Tcp传输【客户端发数据到服务端】，【客户端】建立的过程：：
----------------------------------------------------------------------------
1、Socket类的两个常用构造方法：用来建立连接
new Socket(InetAddress address, int port); // 对方的IP地址和端口
new Socket(String host, int port);  // 或者这样建立，简单

2、如果连接建立成功，说明数据传输通道已建立，这个通道就是输入输出流。
专业叫 socket流，也叫网络IO流。socket流是底层建立的，不需要我们建立，它里面既有输入也有输出。
想要输入流对象或输出流对象，可以找Socket来获取。它是字节流。
可以通过 Socket对象的 getOutputStream() 和 getInputStream() 来获取字节流

3、使用输出流( getOutputStream )，将数据写出，因为是咱们自己机器写出去到网络上。
4、关闭资源。

代码：：
Socket sc = new Socket("10.12.128.161", 10001);
OutputStream outputStream = sc.getOutputStream();
outputStream.write("你好宫海涛".getBytes());
// 告诉服务端，我的输入流写完了，完事了。也就是写个结束标记，不然服务器端会一直等着读，也不知道你写完了。
sc.shutdownOutput();
sc.close();



Tcp传输【服务端接收客户端的数据】，【服务端】建立的过程：：
----------------------------------------------------------------------------
1、Socket服务端用 ServerSocket类。它的构造方法：
new ServerSocket(10000); //指定端口号
2、获取连接过来的客户端对象。(可能很多客户端连过来，本次处理的是哪个？3,4步都是征对这个客户端处理)
3、通过客户端对象获取socket流，读取客户端发来的数据，并打印在控制台上。
4、关闭资源，需要关两个资源：客户端的和服务端的。


代码：：
ServerSocket sso = new ServerSocket(10001);
// 获取客户端对象
Socket sc = sso.accept();// 这是阻塞式的，如果没有客户端来，我就一直在等，等着提供服务
String ip = sc.getInetAddress().getHostAddress();
// 通过socket对象获取输入流，要读取客户端发来的数据
InputStream in = sc.getInputStream();
byte[] buf = new byte[1024];
int len = 0;
while ((len = in.read(buf)) != -1) {
    System.out.println(ip+new String(buf, 0, len));
}
// 关客户端
sc.close();
sso.close();    // 关服务端



还有两个重要的方法：：
因为客户端发了信息给服务器，服务器在read的时候，并不知道它什么时候结束。所以客户端在write完成后需要发个结束标记给服务器。
// 告诉服务端，我的输入流写完了，完事了。也就是写个结束标记，不然服务器端会一直等着读，也不知道你写完了。
sc.shutdownOutput();
而服务器端如果想忽略客户端传过来的内容，而直接给他一个反馈的时候，也可以这样操作：：
// 禁用此客户端的输出流，也就是认为他还没开始就结束了，也就是没有数据。整个while都不用执行了，因为是空的。
sc.shutdownInput();



练习：：：
需求：从客户端键盘输入文字，在服务端转换成大小并输出给客户端
src/main/java/cn/jhsoft/study/nettcpsocket/TransClient.java
src/main/java/cn/jhsoft/study/nettcpsocket/TransServer.java

需求：上传文本文件，并且服务端给上传成功的回馈
src/main/java/cn/jhsoft/study/nettcpsocket/UploadClient.java
src/main/java/cn/jhsoft/study/nettcpsocket/UploadServer.java
改进了一版，服务端用多线程来实现。
while (true) {
    Socket s = ss.accept();
    // 多线程接收多客户端socket
    new Thread(new UploadImageTask(s)).start();
}
// 上面的while循环，如果是一直在空转，系统会爆掉，因为里面有运算，会占用机器资源。
// 但如果里面有阻塞函数(如ss.accept()，还有read()也是阻塞式函数,如果读不到东西就一直在等)，那就不会爆，因为那里会在等待，并不占系统资源。




自己写代码模拟 Tomcat，让浏览器来访问自己的Tomcat（实际上是一个ServerSocket）
----------------------------------------------------------------------------
访问地址：http://127.0.0.1:8089/
代码：src\main\java\cn\jhsoft\study\nettcpsocket\MyTomcat.java




自己写代码模拟 浏览器，去访问真正Tomcat服务器的网页
----------------------------------------------------------------------------
代码：src\main\java\cn\jhsoft\study\nettcpsocket\MyBrowser.java






URL  统一资源定位符  java.net.URL 包，它指向互联网资源，可以是文件可以是目录
----------------------------------------------------------------------------
URI  统一资源标识符。url是一种特殊的uri，uri还包括如jdbc连接这样的，还有相对的路径等。
URN  统一资源名称。如mailto，news等

方法代码：：
URL url = new URL("http://127.0.0.1:8080/web-ssm/index.jsp?a=1&b=2");
System.out.println("协议:"+url.getProtocol());
System.out.println("主机名:"+url.getHost());
System.out.println("端口:"+url.getPort());
System.out.println("页面+参数:"+url.getFile());
System.out.println("页面地址:"+url.getPath());
System.out.println("参数:"+url.getQuery());
url.openStream();  // 获取服务端返回的 InputStream流。

// 获取url连上去的这个socket 服务端返回来的 流
InputStream in = url.openStream();
byte[] buf = new byte[1024];
int len = 0;
while ((len = in.read(buf)) != -1) {
    System.out.println(new String(buf, 0, len));
}

// 获取url对象的url连接器对象，它是将连接封装成了对象
// 这个对象就是java中内置的可以解析的具体协议对象 + socket
// 上面的 url.openStream() 就是对 conn.getInputStream() 进行了一层包装。
URLConnection conn = url.openConnection();
// 获取头信息里的 Content-Type
System.out.println(conn.getHeaderField("Content-Type"));

// 通过 URLConnection 来获取输入流   conn.getInputStream()



----------------------------------------------------------------------------
------------ 正则表达式  java.util.regex包中的 Pattern类
----------------------------------------------------------------------------
正则表达式主要用来操作字符串，它是通过一些特定的符号来体现的。
Java中，字符串String中有个方法 ： matches(String regex) 可以接受一个规则参数，返回布尔值。
这个规则 就是正则表达式。如：
String qq = "12345678";
String regex = "[1-9][0-9]{4,14}";
boolean b = qq.matches(regex);
System.out.println(b);


规则：：

字符
[abc]        a、b、c 三个中的一个。  简单类
[^abc]       任何字符，除了a,b,c  否定
[a-zA-Z]     a到z或A到Z，包括两头  范围
[a-d[m-p]]   a到d或m到p，[a-dm-p]  并集
[a-z&&[def]]   a-z与def这三个  取交集
[a-z&&[^bc]]    a-z除了b和c，    相当于[ad-z]  减去
[a-z&&[^m-p]]   a-z而且不是m-p     相当于[a-lq-z]  减去

预定义字符
.     任何字符（与行结束符可能匹配也可能不匹配）
\d    数字
\D    非数字
\s    空白字符 [\t\n\x0B\f\r]
\S    非空白字符
\w    数字和大小写字母下划张
\W    上个里取反

边界匹配器
^    行的开头
$    行结尾
\b   单词边界

Greedy数量词
?        一次或一次也没有
*        零次或多次
+        一次或多次
{n}      n次
{n,}     至少n次
{n,m}    n到m次，至少n次，不超过m次

Reluctant数量词
在 Greedy数量词 的基础上加个 ?，如??,*?,+?

Possessive数量词
在 Greedy数量词 的基础上加个 +，如?+,*+,++

正则表达式对字符串的常见操作：
1、匹配，其实就是String类中的matches方法 。
2、切割，其实就是String类中的split函数。

String str = "zhangsan   ab1        ab2";
// 用一个或多个空格来 切割
String[] names = str.split(" +");
for (String name:names){
    System.out.println(name);
}

// . 是正则里的关键词，用它来切割的时候，需要转义。
String str1 = "zhangsan.ab1.ab2";
String[] names1 = str1.split("\\.");
for (String name:names1){
    System.out.println(name);
}

组的概念，按组来切割。
--------------------------------------------------------------------------------------------------------
String str2 = "zhangsan####ab1&&&ab2";
// 叠字,按重复的字符来分隔 括号括起来的是组(.)，正则会把他编号为1,要取他，需要\\1
// 如果没有括号，那就没有组，\\1 就没有意义
// 复杂组 如 ((A)(B(C))) 从左括号看，去数组，第一个左括号是第1组，第二个左括号是第2组，类推
// 组0 代表整个表达式。
String[] names2 = str2.split("(.)\\1+");
for (String name:names2){
    System.out.println(name);
}


3、替换
--------------------------------------------------------------------------------------------------------
其实使用的就是String类中的replaceAll方法
String str2 = "zhangsan####ab1&&&ab2";
// 叠词操作，把多个重复的词，替换为一个 感叹号。与切割时的用法一样。
str2 = str2.replaceAll("(.)\\1+", "!");
System.out.println(str2);

// 把匹配到的 重复的字母替换为一个它自己，如4个#替换为一个#, 多个&替换为1个&
// 第二个参数里使用第一个参数里的正则的结果，$1,$2等。
str2 = str2.replaceAll("(.)\\1+", "$1");
System.out.println(str2);

// 替换手机号中间的*
String str = "15800001111";
str = str.replaceAll("(\\d{3})\\d{4}(\\d{4})", "$1****$2");
System.out.println(str);

4、获取
--------------------------------------------------------------------------------------------------------
替换只能用 java.util.regex.Pattern 和 java.util.regex.Matcher 操作了。
上面三个，用字符串操作的，实际上底层也还是用这种办法。
这里面就有  matchers()  和 replaceAll() 方法 。

// 要得到三个字母组成的单词
String str = "da jia hao,ming tian bu fang jia!";
// Pattern是正则表达式对象      java.util.regex.Pattern
// Matcher是匹配器对象   java.util.regex.Matcher
/**
 获取
    将正则规则进行对象的封装
 Pattern p = Pattern.compile("a*b");
 // 通过正则对象的matcher方法 字符串相关联。获取要对字符串操作的匹配器对象Matcher
 Matcher m = p.matcher("aaaaab");
 // 通过Matcher匹配器对象的方法 对字符串进行操作
 boolean b = m.matchers();    m.find();   m.group()   等
 */

String regex = "\\b[a-z]{3}\\b";

// 1.将正则封装成对象
Pattern p = Pattern.compile(regex);
// 2.通过正则对象获取匹配器对象
Matcher m = p.matcher(str);
// 3.使用Matcher对象的方法 对字符串进行操作
// 既然要获取三个字母组成的单词，那就查找 find()
System.out.println(str);
while(m.find()){
    System.out.println(m.group());  // 获取匹配的子序列
    System.out.println(m.start()+":"+m.end());
}



练习：：
--------------------------------------------------------------------------------------------------------
练习一：治口吃：
String str = "我我...我...我我我要...要要要要...要要要要..学学学...编编程";
// 1.将字符串中的.去掉。用替换
str = str.replaceAll("\\.", "");
// 2.替换叠词
str = str.replaceAll("(.)\\1+", "$1");
System.out.println(str);

练习二：IP排序
String str = "192.168.10.34  127.0.0.1   3.3.3.3    105.70.11.55";

// 1.为了让ip可以按照字符串顺序比较，只要让ip的每一段位数相同。
// 所以，补零，按照每一位所需做多0进行补充，每一段都加两个0
str = str.replaceAll("(\\d+)", "00$1");
// 然后每一段保留数字3位
str = str.replaceAll("(\\d{0,2})(\\d{3})", "$2");
// 再用TreeSet排序，它存储的时候就有顺序
TreeSet<String> ts = new TreeSet<>();

// 2.将ip地址切出，按空格出现1次或多次
String[] ips = str.split(" +");
for (String ip : ips) {
    ts.add(ip);
    System.out.println(ip);
}
for (String ip : ts){
    // 0*后面跟的数字，取那数字，就适用于505这种，没有0后面就是数字，要得到那数字
    // 如果是 005，那就得到5，适合解决那种中间是 0 的正常情况，只要去掉以0开头的情况
    System.out.println(ip.replaceAll("0*(\\d+)", "$1"));
}


练习三：网络爬虫，爬取邮箱
List<String> list = new ArrayList<>();

// 1.读取源文件
//BufferedReader bufr = new BufferedReader(new FileReader("email.html"));
// 上面是获取本地资源，接下来获取网页资源
URL url = new URL("http://www.cnitpm.com/pm1/46030.html");
// url.openStream()获取的是InputStream，要操作文本，需要转化。
BufferedReader bufr = new BufferedReader(new InputStreamReader(url.openStream()));

// 2.对读取的数据进行规则的匹配。从中获取符合规则的数据
String regex = "\\w+@[a-zA-Z0-9]+(\\.\\w+)+";
Pattern pattern = Pattern.compile(regex);

String line = null;
while ((line = bufr.readLine()) != null) {
    // 通过正则对象获取匹配器对象
    Matcher m = pattern.matcher(line);
    // 循环找 m.find() ，找到了就取出找到的结果 m.group()
    while (m.find()){
        list.add(m.group());
    }
}

// 3.将符合规则的数据存储到集合中
for (String str : list){
    System.out.println(str);
}

bufr.close();







########################################################################################################
###################### 面向对象
########################################################################################################
new 新建的，都是在堆内存中
栈内存，如主函数main里一句一句执行的，当涉及到要调别的对象或函数的地方，那些就进到栈内存里了。还有局部变量也在栈内存中。main函数也在栈中。
首先main进栈，他里面的局部变量和他一起进。里面再调个别的函数，别的函数也就进栈了，然后那函数执行完了，他先出栈，再main出栈。
对象被new以后，他就在堆内存中，对象中的成员变量，也在堆内存中，对象初始化的时候，数值成员的初始化值是0，字符串成员初始值是null，

数值类型参数传递，那边改变了不会影响调用方的变量。
引用类型(new出来的)参数传递，那边改变了，会影响调用方那的，因为他们是同一个。

每个类里都会有个默认的构造函数，如果自己定义了个构造函数，那默认的就会消失，构造函数是给类做初始化的，把整形初始化为0，字符串初始化为null
xx行找不到符号 new xxx，这种大多可能是没有默认构造函数造成的。
构造函数是不带返回值的。与类名一致的函数。不能带返回值。【但是那种不想执行底下的初始化语句的时候，还是可以有return的，但是得有if条件满足 再return，而不能是直接return】

this除了代表当前对象，也可以用于在构造函数中调用其他构造函数，如 this("hi");
但是注意：只能定义在构造函数的第一行。因为初始化动作要先执行。不然编译不通过。

static 是一个修饰符，用于修饰成员。他修饰的成员被所有的对象共享。他优先于对象存在，因为static的成员随着类的加载就已经存在了。
static修饰的成员多了一种调用方式（类名.静态成员）。
static修饰的数据是共享数据，对象中存储的是特有数据。

类里的普通字段(非静态字段，也就是没被static修饰的字段)，叫成员变量，也叫实例变量。它存在堆内存中。堆内存中放的都是实例。
类里的静态字段，叫静态变量，也叫类变量。它存在于方法区（共享数据区）的静态区中。所以也叫对象的共享数据。
java的五个内存区：
堆内存、栈内存，方法区（共享数据区）、本地方法区（调系统本地服务的）、寄存器（给cpu的）
静态方法，只能访问静态方法和静态变量。


静态代码块：
--------------------------------------------------------------------------------------------------------
static{
    System.out.println("class run");
}
随着类的加载而执行，只执行一次，类再创建对象时，是不会再执行，一直在内存中。随着类的消失而消失。
它是用于给类做初始化的。构造函数是给对象做初始化的。
如果这个类里全是静态的属性和方法，那这个类就不需要创建对象，所以在这些静态方法调用之前，需要用到static代码块来给这些静态方法做一些之前的准备工作。


构造代码块： 写在类里，与静态代码块放的位置差不多。
--------------------------------------------------------------------------------------------------------
{
    System.out.println("object run");
}
类中的代码块，叫构造对象的代码块，也叫构造代码块。可以给所有对象进行初始化。
如果代码块前不加 static，是指给对象初始化要执行的代码。创建一个对象时，那代码块里的执行一遍。它就和类的创建没关系了。
它具有所有构造方法的共性，也就是说不管调哪个重载的构造方法，都会执行这个构造代码块。而构造函数是给它对应的对象进行针对性的初始化。
创建一个对象时，会先调用 构造代码块，再调用它的构造方法。
如果这个类继承了父类，那super()会比 构造代码块 {} 还要先执行，顺序是 父类构造方法---》构造代码块---》子类构造方法。

局部代码块，{}  是放在非静态方法里，用来限定局部变量的生存周期。
它们的执行顺序是，先静态代码块---》构造代码块---》构造方法

如果一个类，里面的方法都是静态的，那这个类就不需要new，那为了防止别人来new 这个类，那可以把构造方法弄成私有化，那别人就new不了。比如：
private Person() {}  ，这样别人就new不了啦。


文档注释：：：：：
--------------------------------------------------------------------------------------------------------
把public和protected这两种权限的成员和方法信息。

在类上加上：
/**
建立一个人类
@author 陈义
@version 1.1
*/
public class Person{
}

在类的方法里加上 @param   @return  这注释，注意，它只能解析 /**      */ 这种格式的，前面是两个*
/**
求数组的最大值
@param arr 数组
@return 返回该数组的最大值
*/
public static int getMax($arr){return 1;}

生成文档：：：放在当前位置的   myhelp目录下，如果没有会自己创建。
--------------------------------------------------------------------------------------------------------
javadoc -d myhelp -author -version ArrayTool.java

在命令行里设置classpath
set classpath=c:\bigdatabin   设置1个
set classpath=.;%classpath%   设置两个
查看 set classpath


单例设计模式：：
--------------------------------------------------------------------------------------------------------
private static RegexTestDemo obj = new RegexTestDemo();
private RegexTestDemo(){}
public static RegexTestDemo getInstance(){
    return obj;
}

继承的好处：
--------------------------------------------------------------------------------------------------------
1、提高了代码的复用性。
2、让类与类之间产生了关系，给第三个特征 - 多态，提供了前提。

java来自c++，java中支持单继承，不直接支持多继承，但对c++中的多继承机制进行了改良。
单继承：一个子类只能有一个父类。
多继承：一个子类可以有多个直接父类（java中不允许，进行改良，在java中是通过“多实现”的方式来体现。）
不直接支持，是因为会产生调用的不确定性。如多个父类里有同名的方法和成员，子类不知道调哪个父亲的方法。
java支持多层继承，也就是多重继承。C继承B，B继承A，那C就有A和B的特性。
这就出现了继承体系。最顶层里定义的是这个体系里 最基本的内容。

当要使用一个体系时，
1、查看该体系中的顶层类，了解该体系的基本功能。
2、创建体系中的最子类(低层)对象，完成功能的使用。

什么时候继承？
|-不要紧紧为了拿别人的一个东西(如方法1)而继承，因为你拿一个的时候，其他的(方法2，方法3)都拿来了，而你不应该有其它的。
这时应该把它们两个里公用的(方法1)，再往外抽一次，他们两都继承自那个。
|-当类与类之间存在着所属关系的时候，就定义继承。xxx是yyy中的一种，xxx extends yyy

|-在子父类中成员的特点体现：
1、成员变量：子有，就不找父。
在内存中来说，自己空间里有，就不往外找。
当本类的成员和局部重名时，用this来区分本类。
当本类和父类的成员重名时，用super来区分父类。

this和super的用法很相似。
this代表一个本类对象的引用，super代表父类空间，而不是父类对象因为并没有为父类创建对象。
有extends关键词的时候，就已经持有一个super引用。
子类在new一个对象的时候，堆内存里有一块子类的空间，父类也在那块子类的空间里。
他们在同一块堆内存里，但是有自己的标识，this是子类的对象，默认可以省略this，super是父类的那标识的小空间里。
子类中不能直接访问父类私有的内容(属性和方法)
有extends关键词，在方法区内存中，是先加载父类，再加载子类。

2、成员函数：子有，就不找父
子类创建对象，调对象的方法的时候，先去子类找，再去父类找。在子类中找到了，就不会去父类找了
当子父类中出现成员函数一模一样的情况，会运行子类的函数。这种现象，称为覆盖操作。这是函数在子父类中的特性。
函数两个特性：
   重载   同一类中
   覆盖   子类中，也称为重写、覆写。

覆盖的注意事项：：
2.1子类方法覆盖父类方法时，子类权限必须要大于等于父类的权限，才可以引发覆盖。
   在java中如果类或函数和属性 前不加修饰符，默认是 protected保护类型。
2.2子父类方法名，返回值，参数也相同时，静态只能覆盖静态，或被静态覆盖。也就是说他们两要么都static，要么都不static.

######################### 什么时候使用覆盖操作：：
#当对一个类进行子类的扩展时，子类需要保留父类的功能声明，
但是要定义子类中该功能的特有功能时，就使用覆盖操作完成。

3、子父类中构造函数的特点。
在子类构造对象时，发现，访问子类的构造函数时，父亲的构造函数也运行了。
为什么呢？
原因是：在子类的构造函数中第一行有一个默认的隐式语句，super(); 也就是调父类的空参数的构造函数。
就像普通的类，如果没写构造函数，会有个隐式的空的不带参数的构造函数。
子类不会继承父类的构造函数，但是默认有隐式调父类的空参构造函数。如果父类没有空参的构造函数
需要显示的调用(隐式的就不再有了)，并传参数进去，不然编译不通过。
子类的实例化过程：：
子类中的所有构造函数(无参或有参等所有)，默认都会访问父类中的空参的构造函数。

############## 为什么子类构造函数里，默认会隐式的调用父类空参构造方法呢？
那是因为子类继承了父类，获取到了父类中的内容（属性）。所以在使用父类内容之前，要先看父类是如何对自己的内容进行初始化的。
也就是说父类本身要对它的成员进行初始化，如果不先访问父类的构造函数，那子类访问到的父类的成员变量就是空的。
所以子类在构造对象时，必须访问父类中的构造函数。
为了完成这个必须的动作，就在子类的构造函数中加了隐式的默认的 super() 语句。
如果父类中没有定义空参的构造函数，那子类的构造函数必须用super明确要调用的父类中的哪个有参的构造函数。

############## 同时子类构造函数中如果用了this()调用本类的构造函数时，那么super就没有了，因为super和this都只能定义在第一行。所以只能有一个。
但是可以保证的是，子类中肯定会有其他的构造函数访问父类的构造函数。
因为this()调用的那个构造方法，第一行肯定不会是this()了，即使是，那他也不能是调重复的构造函数，不然就死循环了，所以总会有一个构造函数第一行不是this()，那就调了super()了。

############## 注意：：：super语句必须要定义在子类构造函数的第一行，因为父类的初始化动作要先完成。否则编译不通过。
：：： this() 和 super() 都只能写在构造方法的第一行。

public class Demo{
    /*
    隐式的构造方法，默认里面有这两句。
    Demo(){
        super();  // 这是调上帝 Object 的构造方法。
        return;
    }
    */
}
如果类的前面有个 public，那构造函数的前面如果没写，那默认也是public的。就不是默认不写就是protected了。

通过super()初始化父类内容时，子类的成员变量并未显示初始化。
等super()执行完毕后，才进行子类的成员变量显示初始化。如：
class Fu{}
class Zi extends Fu{
    int num = 8;
    Zi(){
        【num 默认初始化 为0】
        // 下面这话是分水岭
        super(); // 这句话执行之前，num是0，执行之后num就是8了，######## 这是分水岭。###########
        【num 显示初始化 为8】
    }
}
如果子类的方法覆盖了父类的方法，用子类来new对象时，父类的构造函数里调用了这个方法，则是调子类的。
因为这种情况，子类在堆内存中，谁调用都要先调子类的，子类没有再找父类的。


################## 一个对象实例化的过程：：
Person p = new Person();
1、jvm会去读取指定路径下(classpath)的Person.class这个字节码文件，并加载进内存。
   并会先加载Person的父类（如果有直接父类的情况下）
2、在堆内存中开辟空间，分配地址。
3、并在对象空间中，对对象中的属性进行【默认初始化】(0和null)
4、调用对应的构造函数进行初始化。
5、在构造函数中，第一行会先调用父类中的构造函数进行初始化。
6、父类初始化完毕后，再对子类的属性进行【显示初始化】  。
7、在进行子类构造函数的特定初始化。
8、初始化完毕后，将地址值赋值给引用变量。


##### final关键字：  字面意思是  【最终】。
1、final是一个修饰符，可以修饰类、方法、变量。
2、修饰类的时候，可以理解成 【最终类】 ，不允许别人继承。
3、修饰方法的时候，理解成 【最终方法】，不允许子类覆盖这个方法。
   补充点知识，如果父类的方法是private，子类也有个这完全相同的方法，那就不叫覆盖，可以理解成不同的方法。这时就子类可以把父类这个private忽略掉，当做看不见不存在。
4、修饰变量的时候，【最终值】，不允许改变它的值。
   叫【常量】，【名字用大写，多个单词用下划线隔开】，因为是终身不能变，所以通常定义在类的成员变量那区域。
   在java中，变量的命名格式和方法是一样的，第一个单词小写后面每个单词首字母大写。
   final修饰的变量，必须显示的初始化。也就是final int PI = 2; 不能不写后面的 = 2
   成员如果有 final修饰，一般都会再带着 static ，static final int PI = 2;

   为什么要用final修饰变量？
   其实程序如果有一个数据是固定的，且他的值是不能变化的，所以加上final。如用来修饰3.14的PI


java中的语句，要么用;结束【这叫抽象方法】，要么用大括号结束（如函数）。




######################################################################################################
--------------------------------------------------------------------------------------------------------
######################################################################################################
抽象类：  abstract
--------------------------------------------------------------------------------------------------------
抽象：字面意义是  笼统，模糊，看不懂，看不清，不具体。
当一个类没有足够的信息来描述一个事物的时候，这就是抽象。

特点：
1、方法只有申明，没有实现时，该方法就是抽象方法，需要被abstract修饰。
   抽象方法必须定义在抽象类中。该类必须也被abstract修饰。
2、抽象类不可以被实例化，不能用new创建。为什么？
   因为调用抽象方法没意义，他没有方法体，不能被执行。
3、抽象类必须有其子类覆盖了所有的抽象方法后，该子类才可以实例化。否则这个子类还是抽象类。

疑问：：
1、抽象类中有构造函数吗？
    有，用于给子类对象进行初始化。
2、抽象类可以不定义抽象方法吗？
    可以。但是很少见，目的就是不让该类创建对象。AWT中的适配器对象就是这种类。
    通常这个类中的方法有方法体，但是却没有内容。
    class Demo{
        void show1(); 没有方法体，这种叫抽象方法。
        void show2(){}  有方法体没内容，其实也有内容，有个隐式的return;
    }
3、抽象关键字不可以和哪些关键字共存？
    private 不行，因为你需要被人实现，又是私有别人又看不见
    static 不行，如果是static，那就是用类就可以访问，直接访问没有方法体，就会出错。
    final不行，抽象是你要覆盖我，final是不让覆盖我。所以他们不能共存
4、抽象类和一般类的异同点？
    相同点：
        抽象类和一般类都是用来描述事物的，都在内部定义了成员，如成员函数和成员变量。
    不同点：
        4.1 一般类有足够的信息描述事物。
            抽象类描述事物的信息有可能不足。
        4.2 一般类中不能定义抽象方法，只能定义非抽象方法。
            抽象类中可以定义抽象方法，同时可以定义非抽象方法。
        4.3 一般类可以被实例化。
            抽象类不可以被实例化。
5、抽象类一定是个父类吗？
    是的。因为需要子类覆盖其方法后才可以对子类实例化。




######################################################################################################
--------------------------------------------------------------------------------------------------------
######################################################################################################
接口：  interface
--------------------------------------------------------------------------------------------------------
当一个抽象类中的方法都是抽象的时候，这时可以将该抽象类用另一种形式定义和表示，就是接口 interface。
接口是特殊的抽象类。定义接口使用interface，不用class。

接口中常见的成员：
1、全局常量。 public static final。
    如果定义的是这个 int NUM = 4; 系统会自动加上 【public static final】 int NUM = 4;
2、抽象方法。 public abstract
    如果定义 void work();     系统会自动加上  【public abstract】 void work();

可以用接口名直接调用里面的全局常量，如Demo.NUM;也可以用实现了接口的类，还有实现了接口类的对象调用全局常量。如：
DemoImpl di = new DemoImpl();  // DemoImpl实现了Demo接口，命名是接口名加Impl
System.out.println(Demo.NUM);
System.out.println(DemoImpl.NUM);
System.out.println(di.NUM);

类和类之间是继承关系，类与接口之间是实现关系。接口与接口之间是继承关系，而且可以多继承(interface B4 extends A4,Demo)。
接口不可以实例化，只能由实现了接口的子类并覆盖了接口中所有的抽象方法后，该子类才可以实例化。
否则这个子类就是一个抽象类。

在java中不直接支持多继承，因为会出现调用的不确定性。
所以java将多继承机制进行改良，在java中变成了多实现【一个类可以实现多个接口】。
多实现的时候，如果多个接口里有相同名字的方法。
实现接口的类，反正都要重写这些方法，同时把那几个接口里的都覆盖了，所以就不存在不确定性了。【对比c++的多继承】

一个类在继承另一个类的同时，还可以实现多个接口。
这就使得 接口的出现避免了单继承的局限性。

接口的特点：：
接口是对外【暴露的规则】也就是对外提供规则。
接口是程序的【功能扩展】。
接口的出现【降低耦合性】。
接口可以用来【多实现】。
接口可以继承另一个接口。而且可以多继承【为什么？】
    因为java不支持多继承是因为多继承，那些父类里可以有完全相同的方法，子类对象不知道调哪个。
    但是接口的多继承就不会出现这种问题，他们有重复的方法，实现类里都会覆盖，实现类里都是要把所有的都覆盖。所以不存在不确定性。

########## 抽象类和接口的异同点：：
相同点：
    都是不断向上抽取而来。
不同点：
    1、抽象类需要被继承而且只能单继承，接口需要被实现而且可以多实现。
    2、抽象类中可以定义抽象方法和非抽象方法，子类继承后，可以直接使用非抽象方法。
       接口中只能定义抽象方法，必须由子类实现。
    3、抽象类的继承，是is a关系，在定义该体系的基本共性内容。
       接口的实现是 like a 关系，在定义体系额外功能。

########## 接口 通常都以  __able 结尾,able的意思是 【可】 。 接口里的方法都是public的。
########## 由类定义的变量，叫类类型变量。接口定义的变量，叫接口变量，也叫接口型的引用。
用于接收（指向）接口的子类(实现类)对象。
如 USB接口， 【USB usb】 这个usb就是接口变量。
参考 src/main/java/cn/jhsoft/study/obj/BookPC.java
类中的解释：：
interface USB{// 暴露的规则、定义规则
public static void useUSB(USB u) // 使用规则，BookPC类在使用规则，达到他的目的。
class Upan implements USB{}  // 实现规则，接口实现类。
useUSB(new Upan());  // 主函数里，使用规则，使功能扩展了。




######################################################################################################
--------------------------------------------------------------------------------------------------------
######################################################################################################
多态：  多种形态（如函数重载和覆盖，这叫函数的多态。这里我们主要是讲对象的多态）
--------------------------------------------------------------------------------------------------------
定义：某一类事物的多种形态。
对象的多态性：
猫 x = new 猫();   //猫类 继承自动物类
动物 x = new 猫();  // 前后不一致，就是多态。也就是一种对象两种形态。他又是动物，又是猫。
猫这类事物即具备猫的形态，又具备动物的形态。这就是对象的多态性。
简单说：就是一个对象对应着不同类型。
多态在代码中的体现：父类或接口的引用指向其子类的对象。

多态的好处：提高了代码的扩展性，前期定义的代码【父类】可以使用后期的内容【各个子类】。

多态的局限性和弊端：：
    前期定义的内容【父类】不能使用(调用)后期子类的特有内容。
    以父类的引用来作为参数传递，这样能用父类里的所有方法(当然如果子类有覆盖就只用子类的咯)。但是子类的方法而父类里没有的，就不能用了。

多态的前提：：
    1、必须有关系，继承或实现。
    2、要有覆盖，如果没有覆盖，那就不叫多态了，所有人都是调父类的方法。子类得覆盖父类的来做自己的事。
    保证这两前提，就可以【提高程序扩展性】。

多态的转型：：
    如 动物 x = new 猫(); // 自动类型提升，猫对象提升到了动物类型。访问上就有局限性，那就不能调用猫里的特有方法，【如捉老鼠】。
    【作用就是限制对特有功能的访问】。如果就只想使用动物的功能【如吃，所有动物都有的方法】，不想使用具体功能【如捉老鼠】。
    专业上讲：叫【向上转型】。也就是将子类型隐藏，不能使用子类的特有方法。

    如果还想用具体动物猫的特有功能。可以将该对象进行【向下转型】。
    猫 y = (猫)x;  // 【向下转型】的目的是为了【使用子类的特有方法】。这样就可以调猫的【捉老鼠方法】

    代码示例：：
    Animal a = new Cat();// 多态，向上转型
    a.eat();  // Animal里有eat方法，Cat对他覆盖了。所以这里会调Cat的eat方法。
    Cat c = (Cat)a;// 向下转型
    c.catchMouse(); // 可以调子类Cat的特有方法

    对于转型，自始至终都是子类对象在做着类型的变化。(一会变成了父类型，一会变成了本类型)
    向上转型的作用：【1、提高扩展性，2、限制对特有功能的访问】父类 a = new 子类()，这就自动向上转型了。
    向下转型的作用：【为了使用子类的特有方法】

    向下转型时类型的判断：：：【instanceof】
    instanceof 对象类型的判断，用于判断对象的具体类型，只能用于引用数据类型的判断。后面可以是接口名也可以是类名。所有子类的对象都 instanceof 父类。
    通常在向下转型前进行判断一下，提高程序的健壮性。
    if (a instanceof Dog) {
        Dog d = (Dog) a;// 向下转型
        d.lookHome();
    }

多态时，成员的特点：
1、成员变量
    【简单说】，【就是编译和运行都参考等号左边】的父类，调用的成员变量以左边父类定义的为准。跟子类的一点关系也没有。
    覆盖只发生在函数上。

2、成员函数（非静态）
    编译时，将子类型隐藏，就不能使用子类的特有方法。
    运行时，参考的是对象所属类中是否有调用的函数，也就是运行右边这个类里的方法。
    简单说就是，【编译看左边，运行看右边】。

3、静态函数
    静态函数，编译时与普通函数一致。
    运行时，因为静态函数不需要靠对象来访问，它是绑定在类上的，所以哪个类创建他，他就执行哪个类里的方法，参考的是左边。
    运行时的情况与成员变量是一致的，谁创建就访问谁。
    简单说就是，【编译和运行都看左边】。
    其实对于静态方法，是不需要对象的，直接用类名就能调用。





内部类
--------------------------------------------------------------------------------------------------------
将一个类定义在另一个类里面，称为内部类，又称嵌套类、内置类。
内部类编译完，会有两个字节码文件。外面的类一个class文件，内部类一个class文件，文件名是【外部类名$内部类名】。

内部类访问特点：
1、内部类可以直接访问外部类中的成员。
2、外部类要访问内部类，必须创建内部类的对象，再用这个对象去调用内部类里的成员或方法。

什么时候用？
一般用于类的设计。分析事物时，发现该事物描述中还有事物，而且这个事物还在访问被描述事物的内容。这时就是还有事物定义成为内部类来描述。
如人体，和心脏。可以把心脏定义为人体的内部类，心脏有他自己的功能，他作为人体类的内部类，方便他访问人体其他器官。
如：
class Outer {
    int age = 10;
    public void main() {
        Inner i = new Inner();
        i.show();
    }
    private class Inner{
        public void show(){
            // 可以自由访问 外面的成员变量
            System.out.println("Inner show"+age);
        }
    }
}
内部类定义在类内部，相当于是外面那个类的成员变量。
那他就可以被修饰符修饰【private class Inner{}】。外部类没这功能。
其它类中，想访问一个类的内部类：：
Outer.Inner inner = new Outer().new Inner();  // 这种不常见，因为内部类基本上会private起来。

内部类如果是static的：
意味着外部类一加载时，内部类就存在了。它就相当于一个外部类。
Outer.Inner inner = new Outer.Inner();

内部类是static，且它的成员是静态的：：
Outer.Inner.show();
##### 如果内部类中定义了静态成员，那内部类也必须是静态。

为什么内部类能直接访问外部类中的成员呢？
那是因为内部类持有了外部类的引用，外部类名.this  来访问
内部类里如果内部类的成员和外部类的成员重复，想访问外部成员的时候，可以 【Outer.this.age】; 这样来访问。

内部类可以存放在局部位置上。如外部类定义个函数，函数里再定义个内部类。
函数里的内部类里，想访问函数的参数，或函数里定义的局部变量，都需要用final来修饰，如：
public void show(final int y){
    final int x = 1;
    class ShowInner{
        public void show(){
            System.out.println("Inner show"+x+y);
        }
    }
}




匿名内部类
--------------------------------------------------------------------------------------------------------
匿名内部类就是内部类的简写形式。

使用前提：
内部类必须继承或实现一个外部类或接口。

匿名内部类其实就是一个匿名【子类对象】。
格式是：
new 父类or接口(){
    子类内容
}
上面这三行，就是一个对象，可以在它后面接着写 .方法()，调对象的方法。如：
new Parent(){
    void show() {
        System.out.println("ni ming show"+num);
    }
}.show();

// 匿名内部类实现接口，这个可以写在方法里
void method(){
    MyInter mi = new MyInter(){
        @Override
        public void show1() {
            System.out.println("show1"+num);
        }
        @Override
        public void show2() {
            System.out.println("show2"+num);
        }
    };
    mi.show1();
    mi.show2();
}

###### 通常使用场景之一：
当函数参数是接口类型时，而且接口中的方法不超过三个。可以用匿名内部类作为实际参数进行传递。
// 匿名类作为参数传递
person.show(     new MyInter() {
    @Override
    public void show1() {
        System.out.println("我是作为参数的show1");
    }
}         );


###### 在静态方法里，要想访问内部类，那内部类也必须是静态的。
面试题：
new Object(){
    void show(){
        System.out.println("object show");
    }
}.show();

Object obj = new Object(){
    void show(){
        System.out.println("object show");
    }
}; // 匿名内部类这个子类对象被向上提升了，转为Object类型了。所以就不能在使用子类中特有的方法了。
obj.show();
第一种写法是对的，他是在创建一个匿名的 Object子类，子类中特有show方法，创建完子类后调用子类的show方法。是可以的。
第二种写法是错的，右边是子类，左边是父类，多态，多态编译时要看左边，左边的object中本身没有show方法，所以编译不通过。

######  new Object()  这叫匿名对象。





--------------------------------------------------------------------------------------------------------
######### 补充：：对象的初始化过程：new Student();它继承自Person
--------------------------------------------------------------------------------------------------------
1、调Student类构造函数，并隐式初始化。
2、调用super()也就是父类的构造函数
3、显示初始化
4、构造代码块初始化。##############
5、Student类构造函数继续执行。上面的2，3，4步都是类似隐藏了的代码，看不见，但实际上有这些动作。


非继承的单类，他的初始化过程：new Person()
1、构造函数执行，并隐式初始化。
2、super()   父类是object类的
3、显示初始化
4、构造代码块初始化
5、继续执行自己的构造函数里的代码。


--------------------------------------------------------------------------------------------------------
######### 补充：：面向对象 知识
--------------------------------------------------------------------------------------------------------
子类覆盖父类中的方法，如果函数名，参数等都相同，但是返回值类型不相同。
那么会编译出错，因为有方法调用的不确定性，不知道到底要返回啥类型。这个很重要。

throw new Exception();
这条语句的后面，不能再有内容，否则会编译不通过。

主函数是静态的，所以只能调用静态成员，和静态方法。。。但是在里面再new别的类，用对象来调用是没问题的。只有他直接调用的会有问题。

try catch finally 组合，如果catch里有个 return; 那finally里的也会执行，但是这个组合之外的代码(也就是 finally之后的)就不会执行了。



Ojbect类
--------------------------------------------------------------------------------------------------------
所有类都有的方法：
clone()
finalize()   //垃圾回收
Class getClass()  //返回当前类所属字节码文件对象。类创建时如 Person p ，首先在堆内存中产生了一个Person.class的字节码文件对象。后面的new Person()就是根据这个字节码文件产生了。
int hashCode()  // 该对象的哈希码值，他内部也是调操作系统本地的 public native int hashCode();是将对象的内部地址转换成一个整数
toString()   //  类名@hashCode这个整数的十六进制(Integer.toHexString(hashCode))。    是这么得到结果的：：：  this.getClass().getName()+"@"+Integer.toHexString(this.hashCode);
wait()
notify()
equals(Object obj)

要比较两个类是否相等，应该在实体类中，重写父类的equals方法。在里面自己定义规则，比如用年龄来比较。返回true。
hashSet和mapSet里看元素是否重复，首先看hasecode再看equals
treeset和treemap 主要是看comparable接口里的compareTo方法 或 实现了compartor接口的 compare方法的类。
Class getClass() 里返回值，是Class类型的，他也是个对象，可以取到他里面的getName等信息【也就是类名】。
println(person1) 其实就是调用 person1.toString(); 并打印出来。



异常 Exception
--------------------------------------------------------------------------------------------------------
异常是在运行时期发生的不正常情况。
在java中用类的形式对不正常情况进行了描述和封装对象。
描述不正常的情况的类，就称为异常类。
以前正常流程代码和问题处理代码相结合，现在将正常流程代码和问题处理代码分离提高阅读性。
其实异常就是java通过面向对象的思想将问题封装成对象，用异常类对其进行描述。
不同的问题用不同的类进行具体的描述，比如角标越界，空指针等。
问题很多，意味着描述的类也很多，将其共性进行向上抽取，就形成了异常体系。

最终 问题(不正常情况)就分成了两大类：
Throwable：【可抛】无论是error还是异常，问题。问题发生就应该可以抛出，让调用者知道并处理。该体系的特点就在于Throwable及其所有的子类都具有可抛性。
    |--1、一般不可处理的。Error类表示
          特点：是由jvm抛出的严重性的总是。已经影响到程序的运行了。这种问题一般不针对性处理，直接修改程序。
               如类不存在(java.lang.NoClassDefFoundError)，内存溢出(java.lang.OutOfMemoryError)。

    |--2、可处理的。Exception类表示
        异常(Exception)的分类：
        2.1、编译时被检测异常，只要是Exception和其子类都是(除了特殊子类RuntimeException体系)。
             这种总是一旦出现，希望在编译时就进行检测，让这种问题有对应的处理方式。
             这样的总是就都可以针对性的处理。

        2.2、编译时不检测异常(运行时异常)，就是Exception中的  RuntimeException及其子类体系。
             这种问题的发生，无法让功能继续，运算无法进行，更多是因为调用者的原因导致的，或引发了内部状态的改变导致的。
             这种问题一般不处理，直接编译通过，在运行时让调用者调用时的程序强制停止。让调用者对代码进行修正。
             这种在开发时更常用 。 这种异常就不需要再继续往外抛【申明 throws】，也不需要try catch，直接程序退出就ok了。


可抛性到底是什么？怎么体现可抛性？
其实就是通过两个关键字来体现的。throws 和throw。凡是可以被这两个关键字所操作的类和对象都具备可抛性。
【throw new MyException()】  这叫【申明异常】。

Throwable类是java语言里异常类的超类  java.lang.Throwable，直接已知子类：Error和Exception
Error类的子类们：
    Error类只有构造方法，自己没有特有的方法。

Exception类的子类们：
    除构造方法，也没有自己的特有方法。

异常体系的特点：
    子类的后缀名都是用其父类名作为后缀，阅读性很强。

异常提示：
    at 类名.方法名<文件名:行号>

throw抛出以后，就会返回调用方，如给主函数，主函数再给虚拟机。
真实开发时，异常信息是不会给用户看的，虚拟机会存起来，作为日志存在，我们可以定期去查看日志。并对程序改进。不需要给用户看。
遇到识别的问题进行对象封装，并返回给调用者，谁调用他给谁，如果没人处理，最终到虚拟机那，到虚拟机那程序就挂了。
异常之后的代码都不会执行了。

自定义异常类：
必须要继承异常体系【要么继承Exception，要么继承RuntimeException】，因为只有称为异常体系的子类才有资格具有可抛性。才可以被两个关键字所操作（throws,throw）。
类名最好以 Exception结尾。
class MyException extends Exception{
    MyException(String message){
        super(message);  // 调父类的显示异常信息的构造方法。
    }
}

【申明抛出】：就是在可能抛异常的那个方法 上加上：throws Exception;
public static void main(String[] args) throws Exception {}
参考：：
src/main/java/cn/jhsoft/study/obj/ErrorDemo.java

###################### Exception体系下【RuntimeException除外】的异常类：
需要要么捕捉【try catch】，要么申明【在函数上 throws 异常类名】,申明的意思就是说我不处理，我再往上层抛。

throws和throw的区别：
1、throws使用在函数上，throw使用在函数内。
2、throws抛出的是异常类，可以抛多个，用逗号隔开。throw抛出的是异常对象（throw new MyException())。

异常处理的捕捉形式：
try{
    需要被检测异常的代码
}
catch(MyException e){
    处理异常 或者继续往外抛
    System.out.println(e.getMessage()+e);
    e.printStackTrace(); //打印出完整的错误信息，如几行出的错，jvm默认的异常处理机制就是调用异常对象的这个方法。
    throw e;   //也可以继续往外抛 ，e是对象，与new Exception()一样，他也是对象。
}
finally{
    最终化，这里不管有没有异常都会执行。只有一种情况执行不到，这种情况是：退出jvm，比如在catch里 【System.exit(0);】
}
try，catch，finally代码组合特点：：
没有必要资源需要释放时，可以不用定义finally。
也可以try  finally组合。就是说不写catch块。不写catch的情况是 放在方法上 throws 抛出。但是finally里的还是会执行。
说白了，这种try finally的组合，就是把 catch的内容放在 方法上的throws中。
try finally就是适合  异常无法直接catch处理，但是资源需要关闭。在try中继续 new throw xxx，在方法上 throws xxx;

###################### 总结：：
一旦在什么地方，throw new Exception()，那这个代码所在的函数就需要 throws Exception，申明他会有异常。
同时，调用这个函数的函数，也需要 throws Exception 申明异常。
在 catch {} 里再throw的，也需要函数 申明 throws Exception
在 try {}里throw的，就不需要申明throws Exception了，因为catch里会捕捉。
总结下，如果是多层调，那每一层都需要要么处理，要么继续往外抛。
简单说，我调一个方法，看到他有 throws，那么我就要处理，要么我也throws，要么我try catch来捕捉。

捕捉是为了解决问题的，如果没有解决，那就没必要try catch了，直接再往外抛 【throws】 就可以了

异常对象的 printStackTrace方法：：：：：
方法含义：将此throwable及其追踪输出至标准错误流如控制台，也可以自己传个输出流(PrintWriter)给他。
void e.printStackTrace(); //打印出完整的错误信息，如几行出的错，jvm默认的异常处理机制就是调用异常对象的这个方法。

多catch的情况下：
按顺序执行。找到一个执行完，后面的catch不会再执行了。
所以写多catch的时候，要把父Exception写在子Exception的前面。

异常处理的原则：：
1、函数内容如果抛出Exception(非RuntimeException)类的异常，那么函数上必须要声明。
    否则必须在函数内用trycatch捕捉，否则编译失败。
2、如果调用了声明异常的函数，要么trycatch要么throws，否则编译失败。
3、什么时候用catch，什么时候用throws呢？
   功能内容可以解决，用catch。解决不了，用throws告诉调用者，由调用者解决。
4、一个功能如果抛出了多个异常，那么调用时，必须对应多个catch进行针对性的处理。
   内部有几个需要检测的异常，就抛几个异常。抛出几个，就catch几个。

异常的注意事项：：：：
1、子类在覆盖父类方法时，父类的方法如果抛出了异常，那么子类的方法只能抛出与父类异常相同的异常或者该异常的子类。
2、如果父类抛出多个异常，那么子类只能抛出父类所抛出的那些异常类的子集，如父类抛出A,B,C，子类则只能抛出A,B，A，C等还有ABC。不能超出。
简单说，子类覆盖父类只能抛出父类的异常或子类或子集。
3、如果父类的方法没有抛出异常，那么子类覆盖时绝对不能抛，只能捕获。参与情况，多线程的run方法里，不能抛，只能try catch



--------------------------------------------------------------------------------------------------------
数组
--------------------------------------------------------------------------------------------------------
堆内存：
    存储的是数组和对象（其实数组就是对象）。凡是new建立的，都在堆中。
    特点：
    1、堆内存里都是存的实体，每一个实体都有首地址值。
    2、堆内存中的每一个变量都有默认初始值，根据类型的不同而不同。整数0，小数0或0.0f，boolean false，char是'\u0000',字符串是null。
    3、垃圾回收机制。


栈内存：
    存储的都是局部变量，而且变量所属的作用域一旦结束，该变量就自动释放。如下面的代码
    void funA(){
        // 局部变量
        int count = 0;

        // 局部代码块
        {
            int a = 1;
        }// 这是局部代码块

        for(int i = 0;i<10;i++){} // for循环的变量也是局部的，一旦for执行完成，他就在内存中消失了。
    }

数组的内存地址：：：：：System.out.println(arr);
[I@29453f44    第一个是[ 代表数组，第二个I 代表整形，后面的是哈希值。
二维数组是  [[@xx  两个 [ 中括号。



数组排序：：：
--------------------------------------------------------------------------------------------------------
int arr[] = {34, 19, 11, 109, 3, 56};
1、选择排序：
/**
 * 选择排序
 * @param arr
 */
public static void selectSort(int[] arr) {
    for (int i = 0; i < arr.length - 1; i++) {
        for (int j = i+1; j < arr.length; j++) {
            if (arr[i] > arr[j]){
                int tmp = arr[j];
                arr[j] = arr[i];
                arr[i] = tmp;
            }
        }
    }
}

2、冒泡排序
/**
 * 冒泡排序
 * 第一轮：从第一个 与后面所有的比一遍，把最大的放在了最后一位了。
 * 第二轮：最后一个数字就不需要参与比较了。再按第一轮一样的方式再打一轮。
 * 也是 大圈套小圈的原理
 * @param arr
 */
public static void bubbleSort(int[] arr) {
    // i 控制外面大圈的圈数
    for (int i = 0; i < arr.length - 1; i++) {
        for (int j = 0; j < arr.length-1-i; j++) { // j控制内圈两个相邻变量之间的对比。中间的j<arr.length-1-i  这个-i 是为了外循环一轮，内圈就少一个，因为最后面的已经不需要参与比较了。
            if (arr[j] > arr[j+1]){
                int tmp = arr[j+1];
                arr[j+1] = arr[j];
                arr[j] = tmp;
            }
        }
    }
}


3、选择排序性能提升
/**
 * 选择排序性能提升  -- 减少交换次数。
 * 大圈套小圈的原理
 * @param arr
 */
public static void selectSort1(int[] arr) {
    for (int i = 0; i < arr.length - 1; i++) {
        // num和index是用来记录外圈循环时，每一轮循环时的最小值， 初始值是第i个元素
        int num = arr[i]; // 记录最小值
        int index = i; // 记录最小值所在的位置
        for (int j = i+1; j < arr.length; j++) {
            if (num > arr[j]){
                num = arr[j];
                index = j;
            }
        }

        // 一个外圈循环只交换一次位置
        if (i != index) {
            int tmp = arr[i];
            arr[i] = arr[index];
            arr[index] = tmp;
        }
    }
}


查找：：
--------------------------------------------------------------------------------------------------------
// 折半查找。这要求被查找的数组是排好序的。专业叫法 二分查找法
int arr1[] = {1,2,3,4,5,6,7,8,9,10,20,30,45,55,60};
/**
 * 二分查找、折半查找
 * @param arr
 */
private static int binarySearch(int[] arr, int searchNum) {
    int min = 0;  // 最小角标，它在循环过程中会不断往右跑
    int max = arr.length - 1;  // 最大角标，它在循环过程中不断往左跑
    int middle = (min + max)/2;  // 最中间的角标
    while (arr[middle] != searchNum) {
        if (searchNum > arr[middle]) { // 比最中间的那个数大，说明在右半边
            min = middle + 1;
        } else if (searchNum < arr[middle]) {
            max = middle - 1;
        }

        if (max < min){  //这说明是找不到，没有再折半的必要。
            return -1;  // 这里如果返回min 是代表如果找不到，插入点的位置在哪。
        }
        middle = (min+max)/2;
    }

    return middle;
}

################ java中本身就有这个工具类：：：【Arrays】
返回插入点：如果没找到，则返回负数。但他多做了一步，说，如果要往arr里插入，应该在哪个位置插入。
Arrays.binarySearch(arr1, 45);


二维数组
--------------------------------------------------------------------------------------------------------
// 创建一个二维数组，该数组中有2个一维数组，每个一维数组中有2个元素。
int[][] a = new int[2][3];  // 第一种定义方式，第二 [3]可以不写3，空着也成   new int[2][];
int[][] b = {{1,2,3},{4,5,6}}; // 第二种定义方式，一维数组是 int[] b = {1,2,3};
a[1][2] = 1;

for (int i = 0; i < b.length; i++) {
    for (int j = 0; j < b[i].length; j++) {
        System.out.println(b[i][j]);
    }
}

// 另外一种创建的方式
int[][] c = new int[2][]; // 列可以不限定，这里是创建了一个二维数组，他有两行。也就是创建了两个一维数组。
System.out.println(c);  // 打印出   [[I@xxx
System.out.println(c[0]);   // 打印出  null
System.out.println(c[0][0]);  // 编译没问题，运行时会出现下标越界的异常。
c[0] = new int[2];
c[1] = new int[3];


// 另外一种创建的方式
int[][] c = new int[2][];
c[0] = new int[2];
c[1] = new int[3];

二维数组，打印二维数组对象，形式是， [[I@xx    与一维数组对比，多了一个中括号。

二维数组的使用场景：：：：




--------------------------------------------------------------------------------------------------------
数据类型：
    基本数据类型：
        数值型：
            整数类型：
                byte 在内存中占1个字节(取值-128到正127)，也就是8位bit（01010101等）。
                short 在内存中占2个字节(-32768到正23767)，16位bit
                int   在内存中占4个字节(上亿)，32位bit
                long   在内存中占8个字节，64位bit。定义的时候long a = 100L，后面要加个【L】。
             浮点类型：
                float 单精度，在内存中用4个字节表示，32bit，float b = 3.14f;
                double 双精度，在内存中用8个字节表示，64bit。通常小数是用这种类型的。

        字符型 char 取值0-65535，装单个字符。也可以放中文'你'，他占2个字节。16bit
        布尔型 boolean

    引用数据类型：
        类(class)
        接口(interface)
        数组([])



类型提升：
在做运算时，占用内存空间小的，会先自动提升为占用内存空间大的那种类型，再做运算。
如 int a = 1; byte b = 2; a+b得3；int a = 1; char b = 3; a+b得4。



################################################################################################
################# 获取 properties 文件内容：：
################################################################################################
Properties pro = new Properties();
// 这是通过Spring的工具类获取
pro.load(new FileInputStream(ResourceUtils.getFile("classpath:common.properties")));
// 原生获取
pro.load(new FileInputStream(new ClassPathResource("common.properties").getFile()));
System.out.println(pro.getProperty("username"));





################################################################################################
################# Spring ：：
################################################################################################
1、Spring是开源的轻量级框架
2、spring核心主要是两个部分：
    2.1 aop：面向切面编程，扩展功能不是修改源代码实现。
    2.2 ioc：控制反转。
        - 比如有一个类，在类里面有方法（不是静态方法），调用类里的方法，是创建类的对象使用对象调用方法，创建类对象的过程，需要new出来对象。
        - 把对象的创建不是通过new方式来实现，而是交给spring配置创建类对象。
3、spring是一站式的框架。
    spring在javaee的三层结构中，每一层都提供不同的解决技术。
    web层  springMvc
    service层  spring里的ioc
    dao层     jdbcTemplate

4、spring版本：
    hibernate5.x
    spring4.x

######### Spring的ioc操作
1、把对象的创建交给spring进行管理

2、ioc操作两部分：
    2.1 ioc的配置文件方式
    2.2 ioc的注解方式

######### ioc底层原理使用的技术：
xml配置文件
dom4j解析xml文件
工厂设计模式
反射

######### 反射创建类：
Class clazz = Class.forName("cn.jhsoft.study.bean.Person");
Person person = (Person) clazz.newInstance();
System.out.println(person.getName());

######### spring的四个核心包：
beans,context,core,expression

######### IOC入门案例：
1、导入jar包
    需要上面那四个核心包 beans,context,core,expression
    <!-- 添加spring核心依赖 -->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-core</artifactId>
        <version>${spring.version}</version>
    </dependency>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>${spring.version}</version>
    </dependency>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-beans</artifactId>
        <version>${spring.version}</version>
    </dependency>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-expression</artifactId>
        <version>${spring.version}</version>
    </dependency>

2、创建类，在类里面创建方法
    如 cn.jhsoft.study.bean.Person类

3、创建spring配置文件，配置创建类
    applicationContext.xml
    注意里面的 schema 约束,与dtd有区别：：
    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://www.springframework.org/schema/beans
                            http://www.springframework.org/schema/beans/spring-beans-4.0.xsd">
        <!--ioc入门-->
        <bean id="person" class="cn.jhsoft.study.bean.Person"></bean>
    </beans>

4、写代码测试对象的创建
    // 加载spring配置文件
    ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
    // 得到配置创建的对象
    Person person = (Person) context.getBean("person");
    System.out.println(person);



######### Spring的bean管理(xml方式)
1、在spring里面通过配置文件创建对象。
2、bean实例化三种方式实现
    使用类的无参数构造创建（常用）
    使用静态工厂创建
        在类里创建静态的方法，返回类对象。类名.xx
        配置文件：
        <!--使用静态工厂创建对象-->
        <bean id="bean2" class="cn.jhsoft.study.spring.IOCDemo" factory-method="getBean2"></bean>
        工厂类IOCDemo：
        public static IOCDemo getBean2(){
            return new IOCDemo();
        }
        调用：
        ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
        IOCDemo bean2 = (IOCDemo) context.getBean("bean2");

    使用实例工厂创建
        创建一个非静态方法，返回类对象。对象.xx
        <!--使用实例工厂创建-->
        <bean id="bean3Factory" class="cn.jhsoft.study.spring.IOCDemo"></bean>
        <bean id="bean3" factory-method="getBean3" factory-bean="bean3Factory"></bean>
        工厂类IOCDemo：
        public IOCDemo getBean3(){
            return new IOCDemo();
        }
        调用与上面完全相同。

3、bean标签常用属性：
    id属性  唯一标识，id属性值任意命名。不能包含特殊符号，只能是英文和数字。根据id值得到配置对象。
    class属性   创建对象所在类的全路径。
    name属性    它的功能跟id本身是相同的，id不能包含特殊符号，name中可以包含特殊符号如#_等。已经被淘汰了。用name不用id，程序也能正常获取getBean()
    scope属性   singleton默认的单例，prototype多例，request 创建对象并把对象放到request域里,session 创建对象并把对象放到session域里,globalSession 创建对象并把对象放到globalSession域里。

######### Spring中属性的注入：：
    1、使用有参数构造的注入
    <!--ioc入门-->
    <bean id="person" class="cn.jhsoft.study.bean.Person">
        <!--使用有参参数向属性里设置值-->
        <constructor-arg name="name" value="陈义1"></constructor-arg>
        <constructor-arg name="age" value="30"></constructor-arg>
    </bean>

    2、通过set方法设置
    <!--使用set方式设置-->
    <property name="name" value="海涛"/>
    <property name="age" value="32"/>

    3、注入对象类型属性（重点）
    UserService类
    public class UserService {
        // 提供set方法，供spring通过set注入
        private UserDao userDao;
        public void setUserDao(UserDao userDao) {
            this.userDao = userDao;
        }

        public void add(){
            System.out.println("service add");
            userDao.add();

        }
    }
    UserDao类
    public class UserDao {
        public void add(){
            System.out.println("add dao...");
        }
    }

    spring配置文件
    <!--注入对象类型属性-->
    <bean id="userDao" class="cn.jhsoft.study.spring.UserDao"></bean>
    <bean id="userService" class="cn.jhsoft.study.spring.UserService">
        <property name="userDao" ref="userDao"></property>
    </bean>

    调用与之前的相同
    // 加载spring配置文件
    ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
    UserService us = (UserService) context.getBean("userService");
    us.add();

    4、p名称空间注入：
    在spring配置文件中，引入约束
    xmlns:p="http://www.springframework.org/schema/p"
    <!--p名称空间注入-->
    <bean id="personp" class="cn.jhsoft.study.bean.Person" p:name="海涛" p:age="25"></bean>

    5、注入复杂类型属性：
    5.1、数组
    5.2、List
    5.3、Map
    5.4、Properties

    <!--注册复杂类型-->
    <bean id="user" class="cn.jhsoft.study.spring.User" p:uname="老宫">
        <!--数组-->
        <property name="arrs">
            <list>
                <value>小宫</value>
                <value>小陈</value>
            </list>
        </property>

        <!--List集合-->
        <property name="list">
            <list>
                <value>小宫1</value>
                <value>小陈1</value>
            </list>
        </property>

        <!--Map集合-->
        <property name="map">
            <map>
                <entry key="a" value="Lucy"></entry>
                <entry key="b" value="Lilei"></entry>
            </map>
        </property>

        <!--Properties-->
        <property name="pro">
            <props>
                <prop key="diverclass">com.mysql.jdbc.Driver</prop>
                <prop key="port">3306</prop>
            </props>
        </property>
    </bean>



######### IOC和DI的区别：
    IOC 是控制反转，把对象创建交给spring进行配置
    DI 是依赖注入，为上一步配置的类里面的属性设置值。

    关系：依赖注入不能单独存在，需要在ioc基础之上完成操作。



######### Spring整合web项目原理：
1、加载spring核心配置文件。
2、实现思想：把加载配置文件和创建对象过程，在服务器启动时完成。
3、实现原理：
    3.1、ServletContext对象
    3.2、监听器
    3.3、具体使用：
        - 在服务器启动时，为每个项目创建一个ServletContext对象。
        - 在ServletContext对象创建时，使用监听器【ServletContextListener接口】可以监听得到ServletContext对象在什么时候创建。
        - 使用监听器监听到ServletContext对象创建的时候。
        - 加载spring配置文件，把配置文件配置对象创建
        - 把创建出来的对象放到ServletContext域对象里面（setAttribute）
        - 获取对象时，到ServletContext域得到（getAttribute）



######### 注解方式：：：创建对象和属性
|- 注解介绍：
1、注解：就是代码里的特殊标记，使用注解可以完成功能。
2、写法：@注解名称(属性名称=属性值)
3、注解使用在 方法上边，属性上边，类上边。

|- Spring注解开发准备工作
1、准备工作：
    导入jar包，spring四个核心包（core,context,beans,expression）
    还需要导入注解包：spring-aop
    创建类，创建方法
    创建spring配置文件，引入约束：
    前一天做ioc基本功能，引入约束beans，
    做spring的ioc注解开发，需要引约束   xmlns:context="http://www.springframework.org/schema/context"
    还需要 在属性 xsi:schemaLocation 里加上：：
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd

    配置文件头：
    <beans xmlns="http://www.springframework.org/schema/beans"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:p="http://www.springframework.org/schema/p"
           xmlns:context="http://www.springframework.org/schema/context"
           xsi:schemaLocation="http://www.springframework.org/schema/beans
                            http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
                            http://www.springframework.org/schema/context
                            http://www.springframework.org/schema/context/spring-context.xsd">

    </beans>

    配置文件就不用前一天那么复杂了，只需要加写这一行：
    <!--开启注解打扫， 【component-scan】 这个的中文名字就是 【注解扫描】。
        （1）到包里面扫描类、方法、属性上面是否有注解。如果 cn.jhsoft这个大包下的所有 【有注解的类】 都扫描，那就写cn.jhsoft。如果想扫描多个包，用逗号分开。
    -->
    <context:component-scan base-package="cn.jhsoft.study.spring"></context:component-scan>

    <!--扫描属性上面的注解，一般也不用，这种方法淘汰了 -->
    <!--<context:annotation-config></context:annotation-config>-->


2、注解创建对象
    2.1、在类(User类)上面加个注解 @Component(value = "user")  //这里面的value可以省略 //他相当于配置文件里的<bean id="user" class="cn.jhsoft.study.spring.User"/>
    2.2、创建对象一共有4个注解：
        @Component   类
        @Controller  WEB层
        @Service     业务层
        @Repository  持久层
        都是用来创建对象，他们功能一致，只是为了后续版本做扩展。
    2.3、创建对象是单实例还是多实例  , 在上面那个注解那块，类上，再加个注解 @Scope(value = "prototype")

3、注解注入属性
    3.1、如创建UserService类 和 UserDao类，他们分别加上注解 @Service("userService") 和 @Component("userDao")

        @Autowired 放在属性上，中文名【自动装配】，Autowired自动装配get和set方法。

        UserService类：：
        @Service("userService")
        public class UserService {
            // Autowired自动装配get和set方法
            @Autowired
            private UserDao userDao;
            public void add(){
                System.out.println("service add");
                userDao.add();

            }
        }

        调用方法和之前的完全相同。

        属性注解的第二种方式：：：
        @Resource(name="userDao")   // 里面的 name属性值 写 注解创建dao对象value值，也就是UserDao类里的注解里的value值。
        private UserDao userDao;

4、配置文件和注解的混合使用：
    4.1、创建对象操作用配置文件的方式。
    4.2、注入属性用注解的方式。


######### AOP （Aspect Oriented Programing）
|- AOP概念
1、aop面向切面（方面）编程，扩展功能不修改源代码实现。
2、aop采取横向抽取机制，取代了传统纵向继承体系重复性代码。

|- AOP原理
使用jdk动态代理，针对有接口的情况。
使用cglib动态代理，针对没有接口的情况。

|- AOP专业术语
Joinpoint(连接点)：所谓连接点是指那些被拦截到的点。在spring中，这些点指的是方法，因为spring只支持方法类型的连接点。
Pointcut(切入点)：所谓切入点是指我们要对哪些Joinpoint进行拦截的定义。
Advice(通知/增强)：所谓通知是指拦截到Joinpoint之后所有要做的事情就是通知，通知分为前置通知，后置通知，异常通知，最终通知，环绕通知（切面要完成的功能）。
Aspect(切面)：是切入点和通知（引介）的结合。
引介
目标对象
织入
代理

通俗讲：
连接点：类里面哪些方法可以被增强，这些方法称为连接点。
* 切入点：在类里面可以有秀多的方法被增强，比如实际操作中，只是增强了类里面add方法和update方法，实际增强的方法称为 切入点。
* 通知/增强：增强的逻辑，称为增强，比如扩展日志功能，这个日志功能称为增强。
            前置通知，在方法之前执行
            后置通知，在方法之后执行
            异常通知，方法出现异常时执行
            最终通知，在后置之后执行
            环绕通知，在方法之前和之后分别执行。
* 切面：把增强应用到具体的方法上面，过程称为切面。它是把增强用到切入点的过程。

参考如下类：
public class UserDao{
    public void add(){}
    public void update(){}
}

######### AOP操作（基于aspectj的xml方式）
1、在spring里面进行aop操作，使用aspectj。
    它不是spring的一部分，它是一个面向切面的框架，它扩展了java语言。它是一个基于java语言的aop框架。
    spring2.0 以后新增了对Aspectj的支持。
2、使用aspectj实现aop有两种方式
    2.1、基于aspectj的xml配置
    2.2、基于aspectj的注解方式

AOP 练习：：
1、引入jar包
    spring-aspects 包
    <!--切面 aspectj-->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-aspects</artifactId>
        <version>${spring.version}</version>
    </dependency>

2、使用表达式配置切入点。
    常用表达式：
    execution(<访问修饰符>?<返回类型><方法名>(<参数>)<异常>)
    2.1、execution(* cn.jhsoft.study.spring.UserDao.add(..))
    2.2、execution(* cn.jhsoft.study.sprion.*(..))
    2.3、execution(* *.*(..))  所有包所有类所有方法，参数任意
    2.4、execution(* save*(..))  增强所有save开头的方法

3、步骤
    3.0、约束
    <beans xmlns="http://www.springframework.org/schema/beans"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:aop="http://www.springframework.org/schema/aop"
           xsi:schemaLocation="http://www.springframework.org/schema/beans
                            http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
                            http://www.springframework.org/schema/aop
                            http://www.springframework.org/schema/aop/spring-aop.xsd">
    </beans>
    比原来多  xmlns:aop="http://www.springframework.org/schema/aop"
    xsi:schemaLocation里多：
    http://www.springframework.org/schema/aop
    http://www.springframework.org/schema/aop/spring-aop.xsd

    3.1、配置对象
    <bean id="ser" class="cn.jhsoft.study.spring.User"></bean>
    <bean id="myUser" class="cn.jhsoft.study.spring.MyUser"></bean>
    3.2、配置aop操作
    <aop:config>
        <!--配置切入点-->
        <aop:pointcut expression="execution(* cn.jhsoft.study.sprion.*(..))" id="pointcut1"/>

        <!--配置切面  把增强用到方法上面 -->
        <aop:aspect ref="myUser">
            <!--配置增强类型，method：增强类里面使用哪个方法-->
            <!--前置-->
            <aop:before method="before1" pointcut-ref="pointcut1"/>
            <!--后置-->
            <aop:after-returning method="after1" pointcut-ref="pointcut1"/>
            <!--环绕-->
            <aop:around method="around1" pointcut-ref="pointcut1"/>
        </aop:aspect>
    </aop:config>


    3.3、环绕通知的代码
    // 环绕通知
    public void around1(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
        // 方法之前
        System.out.println("方法之前。。。");
        // 执行被增强的方法
        proceedingJoinPoint.proceed();
        // 方法之后
        System.out.println("方法之后。。。");
    }

    3.4、测试用例
    @Test
    public void testAOC(){
        // 对User类中的test1进行增强，用myUser中的几个方法来进行增强。
        User user = (User)context.getBean("user");
        user.test1();
    }

######### spring整合web项目：
----------- 问题：加载spring配置文件，要不断的加载，不断的创建对象。
spring web,帮我们创建了监听器，解决这个不断创建的问题，通过监听器，只需要创建一次。

----------- 需要引入包：
spring-web
<!--spring web-->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-web</artifactId>
    <version>${spring.version}</version>
</dependency>

----------- web.xml文件：
<web-app xmlns="http://java.sun.com/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
		  http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
         version="3.0">

    <!--指定spring配置文件的位置 context-param是指上下文参数-->
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:applicationContextAOP.xml</param-value>
    </context-param>

    <!-- spring监听器 -->
    <listener>
        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
    </listener>
</web-app>

----------- 完成上面两步，就不会重复加载spring配置文件了。





######### AOP操作（基于aspectj的 注解 方式）
1、使用注解的方式实现aop操作（1.1和1.2都是修改spring配置文件，他的约束与 xml 方式是完全相同的）
    1.1、创建对象
    <!--1、配置对象-->
    <bean id="user" class="cn.jhsoft.study.spring.User"></bean>
    <bean id="myUser" class="cn.jhsoft.study.spring.MyUser"></bean>

    1.2、在spring核心配置文件中，开启aop扫描操作。
    <!--开启AOP操作-->
    <aop:aspectj-autoproxy></aop:aspectj-autoproxy>

    1.3、完整的配置文件
    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:aop="http://www.springframework.org/schema/aop"
           xsi:schemaLocation="http://www.springframework.org/schema/beans
                            http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
                            http://www.springframework.org/schema/aop
                            http://www.springframework.org/schema/aop/spring-aop.xsd">

        <!--开启AOP操作-->
        <aop:aspectj-autoproxy></aop:aspectj-autoproxy>

        <!--1、配置对象-->
        <bean id="user" class="cn.jhsoft.study.spring.User"></bean>
        <bean id="myUser" class="cn.jhsoft.study.spring.MyUser"></bean>
    </beans>

    1.3、在增强类中用注解的方式实现，MyUser类
    类上面加：：@Aspect  // AOP注解
    方法上面加：
    // 给User类里的所有方法，各种参数类型的，都增强
    @Before(value = "execution(* cn.jhsoft.study.spring.User.*(..))")




######### Spring的jdbcTemplate操作
1、spring框架  一站式框架：
1.1、针对javaee三层，每一层都有解决技术。
1.2、spring对不同的持久层都进行了封装。如mybatis，hibernate,jdbc,jpa等
    jdbcTemplate使用和dbutils使用很相似，都是对数据库进行crud操作。

2、增加操作
    2.1、导入jdbcTemplate使用的jar包。
        spring-jdbc 包  和  spring-tx 包

        <!--jdbcTemplate包-->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-jdbc</artifactId>
            <version>${spring.version}</version>
        </dependency>
        <!--jdbcTemplate 事务包-->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-tx</artifactId>
            <version>${spring.version}</version>
        </dependency>

        导入mysql包：
        <!-- 添加mysql驱动依赖 -->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>${mysql-driver.version}</version>
        </dependency>


    2.2、创建对象，设置数据库信息。
        // 设置数据库信息
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName("com.mysql.jdbc.Driver");
        dataSource.setUrl("jdbc:mysql:///artime365");
        dataSource.setUsername("root");
        dataSource.setPassword("123456");


    2.3、创建jdbcTemplate对象，设置数据源。
    // 创建jdbcTemplate对象
    JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);


    2.4、调用jdbcTemplate对象里面的方法实现操作。
    添加方法，rows是指影响的行数。
    String sql = "insert into tbl_audio values(?,?,?,?,?)";
    int rows = jdbcTemplate.update(sql, null, "1004", "http://www.jd.com", "jd.com", "md5");

    修改和删除和添加一样，都是调用 update方法 。

    2.5、查询方法：
        JdbcTemplate实现查询，有接口RowMapper，jdbcTemplate针对这个接口没有提供实现类，得到不同类型的数据需要自己进行封装。

        2.5.1、查询返回一个值
            String sql = "select count(*) from tbl_audio";
            // queryForObject第一个是sql,第二个是返回值类型，如果是返回字符串 String.class
            int count = jdbcTemplate.queryForObject(sql, Integer.class);

        2.5.2、查询返回对象
        String sql = "select * from tbl_audio where id = ?";
        // queryForObject第一个是sql,
        // 第二个是接口RowMapper，需要自己写实现类实现接口，自己做数据封装。类似dbutils里面的接口
        // 第三个参数是 可变参数
        Audio audio = jdbcTemplate.queryForObject(sql, new MyRowMapper(), 1);


        2.5.3、查询返回List集合
        String sql = "select * from tbl_audio where id>=?";
        // queryForObject第一个是sql,
        // 第二个是接口RowMapper，需要自己写实现类实现接口，自己做数据封装。类似dbutils里面的接口
        // 第三个参数是 可变参数
        List<Audio> list = jdbcTemplate.query(sql, new MyRowMapper(), 1);
        for (Audio audio : list){
            System.out.println(audio.getId()+"-"+audio.getUrl());
        }

        ################ 2.5.2 和 2.5.3 都需要依赖自己写的一个类MyRowMapper，实现RowMapper接口
        /**
         * RowMapper接口
         */
        class MyRowMapper implements RowMapper<Audio>{
            @Override
            public Audio mapRow(ResultSet rs, int rowNum) throws SQLException {
                // 1、从结果集里把数据得到
                String url = rs.getString("url");
                String code_url = rs.getString("code_url");
                int id = rs.getInt("id");
                int count_id = rs.getInt("count_id");
                String count_id_md5 = rs.getString("count_id_md5");


                // 2、把得到的数据封装到对象里
                Audio audio = new Audio();
                audio.setId(id);
                audio.setUrl(url);
                audio.setCode_url(code_url);
                audio.setCount_id(count_id);
                audio.setCount_id_md5(count_id_md5);

                return audio;
            }
        }


######### Spring配置连接池和dao使用jdbcTemplate
1、spring配置c3p0连接池
    1.1、导入jar包
        c3p0.jar 和 mchange-commons-java-0.2.3.4.jar

        <!-- 数据源 c3p0 连接池 -->
        <dependency>
            <groupId>com.mchange</groupId>
            <artifactId>c3p0</artifactId>
            <version>0.9.5-pre8</version>
        </dependency>
        <dependency>
            <groupId>com.mchange</groupId>
            <artifactId>mchange-commons-java</artifactId>
            <version>0.2.12</version>
        </dependency>

    1.2、spring配置文件：
        <!--配置c3p0连接池-->
        <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
            <property name="driverClass" value="com.mysql.jdbc.Driver"></property>
            <property name="jdbcUrl" value="jdbc:mysql:///artime365"></property>
            <property name="user" value="root"></property>
            <property name="password" value="123456"></property>
        </bean>

2、dao使用jdbcTemplate
    2.1、创建Service和Dao类，配置Service和Dao对象。
        通过注解的方法：
        @Component("audioDao")
        public class AudioDao{}

        @Service("audioService")
        public class AudioService{
            @Autowired
            private AudioDao audioDao;
        }

    2.2、在AudioDao类中 添加JdbcTemplate属性
        @Autowired
        private JdbcTemplate jdbcTemplate;

    2.3、在jdbcTemplate对象里面注入 dataSource属性
        <!--创建jdbcTemplate对象-->
        <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
            <!--把dataSource传递到模板对象里面-->
            <property name="dataSource" ref="dataSource"></property>
        </bean>

3、完整代码：
    ------------- spring配置文件：
    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:p="http://www.springframework.org/schema/p"
           xmlns:context="http://www.springframework.org/schema/context"
           xsi:schemaLocation="http://www.springframework.org/schema/beans
                            http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
                            http://www.springframework.org/schema/context
                            http://www.springframework.org/schema/context/spring-context.xsd">

        <!--开启注解打扫-->
        <context:component-scan base-package="cn.jhsoft.study"></context:component-scan>

        <!--配置c3p0连接池-->
        <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
            <property name="driverClass" value="com.mysql.jdbc.Driver"></property>
            <property name="jdbcUrl" value="jdbc:mysql:///artime365"></property>
            <property name="user" value="root"></property>
            <property name="password" value="123456"></property>
        </bean>

        <!--创建jdbcTemplate对象-->
        <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
            <!--把dataSource传递到模板对象里面-->
            <property name="dataSource" ref="dataSource"></property>
        </bean>
    </beans>

    ------------- AudioDao类和AudioService类
    @Component("audioDao")
    public class AudioDao {

        @Autowired
        private JdbcTemplate jdbcTemplate;

        public void add(){
            String sql = "insert into tbl_audio values(?,?,?,?,?)";
            int rows = jdbcTemplate.update(sql, null, "1005", "http://www.jd.com", "jd.com", "md5");
            System.out.println(rows);
        }

    }

    @Service("audioService")
    public class AudioService {

        @Autowired
        private AudioDao audioDao;

        public void add(){
            audioDao.add();
        }

    }

    ------------- 测试
    // 查询表返回List集合
    @Test
    public void testC3P0(){
        ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext_c3p0.xml");
        AudioService audioService = (AudioService)context.getBean("audioService");
        audioService.add();
    }


######### Spring事务管理
1、事务的特性：
    原子性，一致性，隔离性。
2、不考虑隔离性产生读问题

3、解决读问题
    3.1、设置隔离级别

Spring事务管理api
    1、spring事务管理两种方式：
        1.1、编程式事务管理（还需要写代码实现，一般不用）
        1.2、声明式事务管理
            1.2.1、基于xml配置文件实现
            1.2.2、基于注解实现

    2、api事务管理
        首先，配置事务管理器。


######### 搭建【转帐】环境：
1、创建数据库表，添加数据
    CREATE TABLE IF NOT EXISTS `tbl_order` (
      `id` int(11) NOT NULL AUTO_INCREMENT,
      `username` varchar(30) NOT NULL COMMENT '用户名',
      `salary` int(11) DEFAULT NULL,
      PRIMARY KEY (`id`)
    ) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8;

    INSERT INTO `tbl_order` (`id`, `username`, `salary`) VALUES
    	(9, 'chenyi', 1000),
    	(10, 'gonghaitao', 2000);

2、OrderDao类和 OrderService类
    public class OrderService {

        private OrderDao orderDao;

        public void setOrderDao(OrderDao orderDao) {
            this.orderDao = orderDao;
        }

        /**
         * 调用dao方法
         * 业务逻辑层，写转账业务
         */
        public void accountMoney(){
            // chenyi少100
            orderDao.lessMoney();
            // 这是为了测试出现异常，看是否会回滚
            //int i = 10/0;
            // gonghaitoa多100
            orderDao.moreMoney();
        }
    }

    public class OrderDao {

        private JdbcTemplate jdbcTemplate;

        public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {
            this.jdbcTemplate = jdbcTemplate;
        }

        /**
         * 做对数据库操作的方法 ，不管业务方法
         * chenyi 少钱的方法
         */
        public void lessMoney(){
            String sql = "update tbl_order set salary=salary-? where username='chenyi'";
            int rows = jdbcTemplate.update(sql, 100);
            System.out.println(rows);
        }

        /**
         * gonghaitao 多钱的方法
         */
        public void moreMoney(){
            String sql = "update tbl_order set salary=salary+? where username='gonghaitao'";
            int rows = jdbcTemplate.update(sql, 100);
            System.out.println(rows);
        }

    }


3、配置文件，这个配置文件的约束是最全的。
    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:context="http://www.springframework.org/schema/context"
           xmlns:p="http://www.springframework.org/schema/p"
           xmlns:aop="http://www.springframework.org/schema/aop"
           xmlns:tx="http://www.springframework.org/schema/tx"
           xsi:schemaLocation="http://www.springframework.org/schema/beans
                            http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
                            http://www.springframework.org/schema/context
                            http://www.springframework.org/schema/context/spring-context.xsd
                            http://www.springframework.org/schema/aop
                            http://www.springframework.org/schema/aop/spring-aop.xsd
                            http://www.springframework.org/schema/tx
                            http://www.springframework.org/schema/tx/spring-tx.xsd">

        <!--配置c3p0连接池-->
        <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
            <property name="driverClass" value="com.mysql.jdbc.Driver"></property>
            <property name="jdbcUrl" value="jdbc:mysql:///artime365"></property>
            <property name="user" value="root"></property>
            <property name="password" value="123456"></property>
        </bean>

        <bean id="orderDao" class="cn.jhsoft.study.springjdbc.OrderDao">
            <property name="jdbcTemplate" ref="jdbcTemplate"></property>
        </bean>
        <bean id="orderService" class="cn.jhsoft.study.springjdbc.OrderService">
            <property name="orderDao" ref="orderDao"></property>
        </bean>

        <!--创建jdbcTemplate对象-->
        <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
            <!--把dataSource传递到模板对象里面-->
            <property name="dataSource" ref="dataSource"></property>
        </bean>

    </beans>

4、测试
    // 转帐测试
    @Test
    public void testOrder(){
        ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext_all.xml");
        OrderService orderService = (OrderService)context.getBean("orderService");
        orderService.accountMoney();
    }

############# 加事务
5、声明式事务管理（xml）
只需要对spring配置文件进行修改，其他都不需要，配置文件加入如下代码：

    <!--第一步 配置事务管理器-->
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <!--注入dataSource-->
        <property name="dataSource" ref="dataSource"></property>
    </bean>

    <!--第二步 配置事务增强-->
    <tx:advice id="txadvice" transaction-manager="transactionManager">
        <!--做事务操作-->
        <tx:attributes>
            <!--设置进行事务操作 的方法匹配规则-->
            <tx:method name="account*" propagation="REQUIRED"/>
        </tx:attributes>
    </tx:advice>

    <!--第三步 配置切面-->
    <aop:config>
        <!--切入点-->
        <aop:pointcut id="pointcut1" expression="execution(* cn.jhsoft.study.springjdbc.OrderService.*(..))"></aop:pointcut>
        <!--切面，把哪个增强 用到哪个切入点上 -->
        <aop:advisor advice-ref="txadvice" pointcut-ref="pointcut1"></aop:advisor>
    </aop:config>

    再执行上面的测试类即可看到效果，测试时把那个  int i = 10/0; 这行异常打开。

6、声明式事务管理（注解）
    6.1、配置事务管理器，配置文件上面的3步，变成下面2步。
        <!--第一步 配置事务管理器-->
        <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
            <!--注入dataSource-->
            <property name="dataSource" ref="dataSource"></property>
        </bean>

    6.2、配置事务注解
        <!--第二步 开启事务注解-->
        <tx:annotation-driven transaction-manager="transactionManager"></tx:annotation-driven>

    6.3、在要使用事务的方法所在类上添加注解。
    // 对OrderService类下的所有方法进行事务管理
    @Transactional
    public class OrderService {}



######### ssh框架整合：
orm  ：  对象关系映射



######### hibernate：
1、引入jar包：
    <!-- 添加Hibernate -->
    <dependency>
        <groupId>org.hibernate</groupId>
        <artifactId>hibernate-core</artifactId>
        <version>5.0.7.Final</version>
    </dependency>
    <dependency>
        <groupId>org.hibernate</groupId>
        <artifactId>hibernate-entitymanager</artifactId>
        <version>5.0.7.Final</version>
    </dependency>
    <!-- 添加javassist - hibernate会依赖他 -->
    <dependency>
        <groupId>javassist</groupId>
        <artifactId>javassist</artifactId>
        <version>3.12.0.GA</version>
    </dependency>

    <!-- 添加Log4J依赖 -->
    <dependency>
      <groupId>log4j</groupId>
      <artifactId>log4j</artifactId>
      <version>1.2.17</version>
    </dependency>

    <dependency>
       <groupId>org.slf4j</groupId>
       <artifactId>slf4j-nop</artifactId>
       <version>1.7.18</version>
    </dependency>

2、实体类：
    hibernate要求实体类有一个属性唯一

3、配置实体类和数据库表的一一对应关系（映射关系）
    使用配置文件实现映射关系：
    （1）创建xml格式配置文件
        映射配置文件名称和位置没有固定要求，建立在实体类所在包里创建，命名规则：【实体类名称.hbm.xml】
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
                "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
        <hibernate-mapping>
            <!--1、配置类和表对应
                name属性：实体类全路径
                table属性：表名，可以不先建，hibernate会自动建
            -->
            <class name="cn.jhsoft.study.hibernate.entity.Order" table="tbl_order">
                <!--2、配置实体类id和表id对应，hibernate要求实体类有一个属性唯一值，要求表有字段作为唯一值
                name属性：实体类里那个唯一属性名称，他就叫id。
                column属性：生成的表字段名称，数据库里的唯一
                -->
                <id name="id" column="id">
                    <!--设置数据表id增长的策略
                    native值：id是主键并自动增长
                    uuid值：生成128位的UUID，这要求此字段是字符串类型
                    -->
                    <generator class="native"></generator>
                </id>
                <!--配置其他属性和表字段对应 name是实体类的名称, column是字段名称-->
                <property name="username" column="username"></property>
                <property name="salary" column="salary"></property>

            </class>
        </hibernate-mapping>

4、创建hibernate核心配置文件：
    做数据库的配置。如用户名密码、数据库名等。
    （1）核心配置文件格式xml，但是核心配置文件名称和位置固定。
        位置：必须在src下面。
        名称：必须hibernate.cfg.xml
        hibernate操作过程中，只会加载核心配置文件。其他配置文件不会加载。
        第一部分：配置数据库信息  必须的
        第二部分：配置hibernate信息  可选的
        第三部分：把映射文件放到核心配置文件中 必须的

        hibernate.cfg.xml 文件内容：
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
                "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">
        <hibernate-configuration>
            <session-factory>
                <!--第一部分：配置数据库信息 必须-->
                <property name="hibernate.connection.driver_class">com.mysql.jdbc.Driver</property>
                <property name="hibernate.connection.url">jdbc:mysql:///artime365</property>
                <property name="hibernate.connection.username">root</property>
                <property name="hibernate.connection.password">123456</property>

                <!--第二部分：配置hibernate信息 可选-->
                <!--输出底层sql-->
                <property name="hibernate.show_sql">true</property>
                <!--输出底层sql格式-->
                <property name="hibernate.format_sql">true</property>
                <!--hibernate帮创建表，需要配置之后
                update：如果已经有表，更新，如果没有，创建-->
                <property name="hibernate.hbm2ddl.auto">update</property>
                <!--配置数据库方言
                在mysql里实现分页 关键字 limit，只能用到mysql里面
                在oracle数据库，实现分页用 rownum
                让hibernate框架识别不同数据库中的语句-->
                <property name="hibernate.dialect">org.hibernate.dialect.MySQLDialect</property>

                <!--第三部分：把映射文件放到核心配置文件中 必须的-->
                <mapping resource="cn/jhsoft/study/hibernate/entity/user.hbm.xml"></mapping>

            </session-factory>
        </hibernate-configuration>


5、实现添加操作，前4步和后2步都是固定的。
    5.1、加载hibernate核心配置文件

    5.2、创建SessionFactory对象

    5.3、使用SessionFactory创建session对象（与web项目里的session完全不同，本身不是一个东西）

    5.4、开启事务

    5.5、写具体逻辑 crud 操作

    5.6、提交事务

    5.7、关闭资源和连接

    测试代码：
    @Test
    public void testAdd(){
        //1、加载hibernate核心配置文件
        // 到src下面找到名称是 hibernate.cfg.xml
        // 在hibernate里面封装对象
        Configuration cfg = new Configuration();
        cfg.configure();

        //2、创建SessionFactory对象
        // 读取hibernate核心配置文件内容，创建sessionFactory
        // 在过程中，根据映射关系，在配置数据库里面把表创建
        SessionFactory sessionFactory = cfg.buildSessionFactory();

        //3、使用SessionFactory创建session对象（与web项目里的session完全不同，本身不是一个东西）
        // 类似于Connection连接
        Session session = sessionFactory.openSession();

        //4、开启事务
        Transaction tx = session.beginTransaction();

        //5、写具体逻辑 crud 操作
        // 添加功能
        Order order = new Order();
        order.setUsername("cjh");
        order.setSalary(2500);
        // 调用session里的方法实现添加
        session.save(order);

        //6、提交事务
        tx.commit();

        //7、关闭资源和连接
        session.close();
        sessionFactory.close();

    }

根据ID查询：：：
    // 第一个参数是实体类，第二个参数是ID值（主键值）
    Order order = session.get(Order.class, 1);

修改：：：
    首先查询，再修改值。
    // 第一个参数是实体类，第二个参数是ID值（主键值）
    Order order = session.get(Order.class, 1);
    order.setUsername("hahaha");
    session.update(order);

删除：：：
    先查询，再删除
    Order order = session.get(Order.class, 1);
    session.delete(order);

    // 第二种删除方法
    Order order1 = new Order();
    order1.setId(1);
    session.delete(order1);


################# 解决一个问题：
在hibernate中，出现org.hibernate.MappingNotFoundException: resource:**.hbm.xml not found问题的解决方案：
原因：如果idea项目里，在src/main/java目录里有xml文件，在编译的时候，是不会把它复制到target/classes目录下，需要显示的指定：
<build>
    <resources>
        <resource>
            <directory>src/main/java</directory>
            <includes>
                <include>**/*.xml</include>
            </includes>
        </resource>
    </resources>
</build>




















































