1、父类或接口名 创建对象，用子类来 new ，这个对象如果调 属性是调 的父类的，如果调 方法则是调 子类的。
如 class A;
 class B extends A;
  A a = new B();
2、类继承了一个接口，接口里没有定义方法，而子类里有。则会编译错误。
3、父类有一个方法，如果子类里再有一个相同的，但是是prive私有的，则会出错。或者父亲和子类方法名参数名一致，但是返回值类型不一致也会编译错误，因为方法歧义。
4、对象 print的时候，会打印哈希值出来，如果想打印的好看，在类中重写下toString方法来输出类的属性。
5、Ascii码转为字符   (char)97   得到 b
\r   的Asicc码是 13
\n   的Asicc码是 10
     比如 int a = 10; 可以直接这样比较 if (a == '\n'){}
     iso8859-1 是拉丁语表。
6、集合清空是 clear，StringBuffer和StringBuilder清空是 delete。
7、java中字符用unicode码，中文用gbk码。全世界通用，两个字节表示全世界的文字。
如果是a,b这种字符，会在他前面加上 8个0，最后是全世界两位。
由于2个字节来装，太占空间了，后来产生了utf-8编码，有几个就占几个。utf-8里一个中文占3个字节
8、字节(byte)，位(bit)，的概念
1个字节也就是1个英文字符，gbk编码下1个中文是2字节，utf-8编码下1个中文是3个字节
1个字节等于8位。
1024个byte是 1kb
char、byte、int对于英文字符，可以相互转化

9、整数在内存中占4个字节。
10、端口号 是0-65535之间的数字，0-1024之间的端口系统在用，我们的应用最好不要用这些端口。
11、192.168.31.255   这最后一位是255的，是代表广播地址，往这个地址上发信息，会往所有  192.168.31.1 到时 192.168.31.254 之间的ip发信息。



进程：正在进行中的程序
线程：就是进程中 一个负责程序执行的控制单元（执行路径）。一个进程中至少要有一个线程，称为主线程。
多线程：多条执行路径同时进行。
开启多个线程，是为了同时运行多部分代码。每一个线程都有自己运行的内容，这个内容称为线程要执行的任务。
他们同时进行。
多线程的弊端：线程太多回收效率降低
其实应用程序的执行都是cpu在做着快速的切换完成的。这个切换是随机的。

JVM启动时就自动启了多个线程，至少有两个线程可以分析出来
1、执行main函数的线程。 该线程的任务代码都定义在main函数中。
2、负责垃圾回收的线程。  他的任务代码是在垃圾回收器里定义的。底层内部完成。
垃圾回收：System.gc();
在垃圾回收的时候，在类里，可以写个 finalize() 方法，在gc的时候，会调用那个方法，那方法里可以做一些保存呀，发消息呀之类的事件处理。
class Demo extends Object{
    public void finalize(){
        System.out.println("gc demo");
    }
}
class ThreadDemo{
    public static void main(String[] args){
        new Demo(); // 匿名类产生垃圾
        System.gc();
        System.out.println("main ok");
    }
}
主线程结束了，也就是main里的代码执行到最后一行，不代表jvm虚拟机就结束了，虚拟机里还有其他线程在执行。

创建线程方式：
继承Thread类。
实现Runnable接口。
-> 好处：1、将线程的任务从线程的子类中分离出来进行了单独封装，按面向对象的思想将任务封装成对象
2、避免了java单继承的局限性。
所以创建线程的第二种方式更常用。

主线程如果挂了，子线程还是会执行的。
CPU的执行资格   可以被cpu处理，在处理队列中排队
CPU的执行权     正在被cpu处理。

线程的5种状态：
被创建
运行状态   有cpu的执行资格和执行权
冻结状态   释放执行权的同时释放执行资格，没有cpu的执行资格和执行权。
消亡状态
临时阻塞状态     具备执行资格，但是不具备执行权，正在等待执行权，是临时阻塞。他和运行状态，两者不断的切换。
->如A,B,C,D4个线程同时执行，当cpu正在执行A的时候，bcd是临时阻塞状态。

sleep(1000)   等待，1秒后又重新有了执行权和执行资格。

------ 等待唤醒机制
wait()   等待   需要靠 notify() 唤醒，他才能重新争夺执行权和执行资格。让线程处于冻结状态，被wait的线程会被存储到线程池中。
notify() 唤醒同锁线程池中的一个线程(任意)
notifyAll() 唤醒同锁线程池中的所有线程，让他们具有被cpu执行的资格
以上这三个方法必须定义在同步中。因为这些方法是用于操作线程状态的方法。必须要明确到底操作的是哪个锁上的线程。
操作这三个方法，前面需要加上锁名.，也就是锁那个对象，如，obj.wait()

栈内存  main方法执行，里面调了a方法，b方法，那main先入栈，a再入栈，执行完a后，a出栈，b再入栈，b执行完了b出栈，main再出栈。如果出异常，则立即出栈。
堆内存  如成员变量。

##异常会包含4部分信息：
线程，异常类型，异常信息，在什么位置。

线程安全问题产生的原因：
1、多个线程在操作共享的数据。
2、操作共享数据的线程代码有多条。
当一个线程在执行操作共享数据的多条代码过程中，其他线程参与了运算。就会导致线程安全问题的产生。
因为可能有多条语句，执行完其中一条，那cpu就可能切走了，在没有减之前，别的线程就进来了。
解决思路：
将多条操作共享数据的线程代码封装起来，当有线程在执行这些代码的时候，其他线程不可以进来。
解决办法：
一、同步代码块
synchronized(对象){  // 这个对象就直接用this就行
    需要被同步的代码，也就是不安全操作的那几条代码
}
同步的好处：解决线程安全问题
弊端：相对降低了效率。因为同步外的线程都会不停的判断同步锁。
同步的前提：必须有多个线程，并他们使用同一个锁。

二、同步函数：里面的锁对象是 this
与同步代码块一样，只不过刚好需要同步的代码就在一个函数中，就省得再多写 synchronized(对象){}，只需要在函数前面加个修饰符
public synchronized void funcA() {}

三、静态同步函数  里面的锁对象是 ：  this.getClass()、类名.class
该函数所属的字节码文件对象  是  类名.class(class是属性，任何类都有)，或对象.getClass()，(这个类的任意的对象)
## 字节码文件对象，也就是静态类，静态方法，等他们一开始加载到内存时，他们所在的对象，也就是类本身：
Class clazz = Object.class;(类名.class)    或  Class clazz = t.getClass()  对象.getClass() 【用对象去获取(t是new出来的对象)，或者 this.getClass();】
在静态方法里，如果要加同步代码块，那对象只能是 类名.class这种形式。因为那会还没有this，也没有obj

单例模式有两种形式，一种是饿汉式的，一种是懒汉式的。饿汉式是在类加载到内存时，便把对象new出来了，getInstance方法中只是返回，这不会出现多线程安全问题。
懒汉式是，类加载时不new对象，在getInstance方法中判断如果为null再new，这时就因为这一个判断，是多条语句，就产生了安全问题。需要加同步代码块锁来解决。

死锁：是指同步块嵌套同步块，或同步函数里有同步块，这种我拿着我的锁不放，你拿着你的锁不放，导致我执行不到你的代码块，你执行不了我的代码块。程序就僵持在那里。

### 线程间通信：
多个线程在处理同一资源，但是任务却不同。举例：火车把煤运来了，汽车要把煤拉走。他们是不同的任务，不同的线程，但是资源是同一个。

### 锁对象Lock
 * Lock接口  代替了synchronized
 * condition接口   代替了object锁名
 * jdk1.5之后，把同步代码块，这种隐式锁，替换成了Lock对象，将隐式动作变成了显式动作(封装到lock对象的方法中了)
 可以一个锁上加多个监视器。
 lockObj.lock()  获取锁
 lockObj.unlock()   释放锁，通常需要定义在finally代码块中

 Condition接口【监视器】：替代了Object中的wait notify notifyAll方法。
 将这些监视器方法单独进行了封装，变成Condition监视器对象。可以和任意锁进行组合。

 中止线程：interrupt()
 它是将线程从冻结状态强制恢复到运行状态中来，使线程具备cpu的执行资格。
 当强制动作发生了InterruptedException，记得要处理。

 守护线程或用户线程、联合进程：   setDaemon(true),在启动线程之前调用。
 它也叫 后台进程。只要前台进程都结束了，后台进程也就结束了。前台进程就是没加这个的那些进程。
 举例：你负责输入，我负责输出，你不输入我就不输出，你要是结束了，我也就结束了。我是后台进程。用在这里。

 join方法。临时加入一个线程运算，其他的线程要等这个线程运算完才能算。
 如  thread1.join()  这个方法的名字叫，"等待线程终止"。在哪个线程如主线程，执行到 join方法，那个线程就让出执行权，其他的都等待。

 toString()方法，Thread.currentThread().toString()   线程对象的字符串
 优先级：
 thread1.setPriority(Thread.MAX_PRIORITY)   // 争夺cpu执行权的 最大优先级，还有最小Thread.MIN_PRIORITY 和默认Thread.NORM_PRIORITY
 线程组：  今后可以对一组线程进行操作。
 new Thread(new ThreadGroup(), Runnable target)
 释放cpu执行权，自己和其他线程都有再抢夺的机会，这样使执行更均衡一些
 thread1.yield();




///----------------------------------------------------------------------------------------------------------------------
1、字符串比较，忽略大小写：
"ab".equalsIgnoreCase("AB")
2、字符串中是否包含指定字符串
"ab".contains("a");
3、字符串是否以 指定字符串开头和结尾
"ab".startsWith("a")  或    endsWith("b")
4、字符串比较,按字典顺序比较两个字符串 compareTo，返回两个字的字典差距（返回0，大于0的整数，小于0的整数）
前面的比后面大，返回正数，比后面小返回负数，相同返回0
"be".compareTo("ba")    返回4
5、indexOf  找子串第一次出现的位置，如果没找到返回-1.
"abc".indexOf("d")     可以传第二个参数，代表从哪个位置开始找
"abca".indexOf("a", 2)

/// -------------
StringBuffer 字符缓冲区
StringBuffer sb = new StringBuffer();
sb.append("sb").append(true);
sb.insert(1, "sbsb");  // 在指定位置插入
sb.delete(start, end)  // 包含头不包含尾，从第start位开始删除，删到end，不包含end
sb.deleteCharAt(int index)   // 删除指定的一个
sb.delete(0, sb.length())    // 清空缓冲区
查找
sb.charAt(index)         查找字符，返回char
sb.indexOf(string)
sb.lastIndexOf(string)
替换
sb.replace(1,2,"ss")   把1到2位，替换为ss

/// --------------
StringBuilder 与 StringBuffer等价。他是jdk1.5才出现的，而StringBuffer是jdk1.1就出现了。
StringBuilder不保证线程同步，也就是线程不安全。而StringBuffer是线程安全。
如果是单线程的，还是要用 StringBuilder,因为他不同步，所以速度快效率高。

jdk升级的目的：
1、简化书写
2、提高效率
3、增加安全性

/// ---------------
基本类型包装类
int Integer
byte Byte
short Short
long  Long
float  Float
double  Double
char  Character
boolean  Boolean


Interger.valueOf("12345")  等价于
Interger.parseInt("12345")
字符串转为基本类型： 使用包装类的静态方法   xxx  parseXxx("xxx类型的字符串")
int parseInt("123")
long parseLong("123")
Integer 包装类型转为基本类型    非静态方法  intValue()

Integer进制转换：
System.out.println(Integer.toBinaryString(10)); // 二进制
System.out.println(Integer.toHexString(10)); // 十六进制
System.out.println(Integer.toOctalString(10)); // 八进制
System.out.println(Integer.toString(60, 8)); // 转八进制，后面的进制随便自己传

// 其他进制转 2进制，后面的radix参数是随便自己传
System.out.println(Integer.parseInt("110", 2));


########################################################################################################
###################### 集合
########################################################################################################
集合的特点：
1、用于存储对象的容器
2、集合的长度是可变的
3、集合中不可以存储基本数据类型值
4、集合打印时直接打印元素值，方便观看。返回的字符串，直接system.out.println输入。

集合容器因为内部的数据结构不同，有多种具体容器。不断向上抽取，最终形成了集合框架
集合的框架顶层是  Collection
常见的方法：
-添加
boolean add(Obj),
boolean addAll(Collection coll) 添加一组，参数里传个集合进去
-删除
boolean remove(Obj)      // 集合的remove方法是会改变集合长度
boolean removeAll(Collection coll)     // 将两个集合中的相同元素 从调用removeAll方法的集合中删除
void clear()
-判断,是否包含
boolean boolean contains(obj)
boolean containsAll(Collection coll)
boolean isEmpty() 集合中是否有元素
-获取
int size()    元素个数
Iterator<E> iterator()  返回迭代器对象
-其它方法：
boolean retainAll(Collection coll)   取交集，// retainAll功能刚与removeAll相反，把两集合中不同元素 从调用retainAll方法的集合中删除
Object[] toArray   将集合变为数组

#### 迭代器的循环：while循环，下面这种比while更好：
for(Iterator it = coll.iterator(); it.hasNext();){
   System.out.println(it.next());
}

Collection两个派系：
List列表和Set集合（它们两是接口）
|--List     有序（存入和取出的顺序一致），元素都有索引（角标）。元素可以重复。（三个常用的实现类：ArrayList, LinkedList, Vector）
|--Set      元素不能重复，无序。

List：特有的常见方法：有一个共性特点就是都可以操作角标
|--添加：
void add (int index, Obj element)     // 向角标位置添加元素
void addAll(int index, Collection coll)
|--删除
Object remove(int index)
|--修改
Object set(int index, Obj element)  // 修改指定位置的元素
|--获取
Object get(int index)    // 获取单个元素
int indexOf(Obj element)
int lastIndexOf(Obj element)
List subList(int from, int to)    // 获取指定位置区间的列表，包括前面的角标，不包括后面的角标。

|--List能完成对元素的增删改查。
除了Iterator取所有元素外(用while 或 for)，List还有特有的取所有元素方法：
for (int i = 0; i < list.size(); i++) {
    System.out.println(list.get(i));
}
|-- ListIterator 列表迭代器，List特有
在迭代器迭代过程中，不要使用集合操作元素（如修改），会出异常。
可以用Iterrator接口的子接口ListIterator来完成在迭代中对元素进行更多的操作，因为那个listIterator提供了set,remove等方法，可以一边迭代List,一边修改List
List list = new ArrayList();
list.add("abc1");
list.add("abc2");
ListIterator lit = list.listIterator();   // list.listIterator(1); 是从指定位置开始迭代
while (lit.hasNext()) {

    Object obj = lit.next();
    if (obj.equals("abc2")){
        lit.set("abc222");
    }
    if (obj.equals("abc6")){
        lit.remove();
    }
}
System.out.println(list);

// 逆向遍历，hasPrevious相当于hasNext，previous()相当于next()
while (lit.hasPrevious()) {
    System.out.println(lit.previous());
}

|---- List接口的三个常见实现类    ArrayList, LinkedList, Vector
    |-- Vector ： 内部是数组数据结构。内存空间连续。具有List的所有特点。是同步的，线程安全。已过时，基本不用。增删改查都很慢。
    |-- ArrayList ： 内部是数组数据结构，是不同步的，线程不安全。替代了Vector。如果是需要多线程，可以给ArrayList加锁（把添加删除方法放在同一把锁里）。
                     特点是查询快修改慢。查询快的原因，是因为地址连续，只要在那一片空间里查找，所以快。修改慢是因为插入一个元素，得移动其他几乎所有元素。
    |-- LinkedList ：内部是链表结构，非同步。链表这种数据结构，由于每个元素记录了他之后元素的地址，增删改的速度特别快，
                     只需要改变下记录的后面元素的地址，和改变下之前元素中记录的他后面一个元素的地址，不用像数组那样每个元素都进行移动。
                     但是数组结构形式的，查询速度快。而链表形式的查询速度慢。



|-LinkedList特有的方法：   LinkedList link = new LinkedList();
void addFirst(Obj element)    往头部添加
void addLast(Obj element)    往末尾添加
jdk1.6加入了如下替代方法：
offFirst()
offLast()

查询头尾：
getFirst   获取但不移除，如果链表为空，抛出NoSuchElementException
getLast。
jdk1.6加入了如下替代方法：
peekFirst      获取但不移除，如果链表为空，返回null
peekLast

删除：
removeFirst    // 获取并移除，如果链表为空，抛出NoSuchElementException 。removeFirst会返回删除的那个元素。
removeLast
jdk1.6加入了如下替代方法：
pollFirst      获取并移除，如果链表为空，返回null
pollLast


|- 请使用LinkedList来模拟一个堆栈或队列数据结构
|-- 堆栈  先进后出  First in Last out     FILO       举例：吐
|-- 队列  先进先出  First in First out    FIFO       举例：拉屎

// ----------------------------------------------------------
Set ： 元素不可以重复，是无序
|- Set接口中的方法与Collection一致。
子类：也就是实现类  HashSet,TreeSet
|- HashSet ：  内部数据结构是哈希表。无序，迭代也无序，顺序会变化，允许null元素，不同步，线程不安全。性能稳定。
  |- LinkedHashSet         HashSet再加一层链表。查找方便。
|- TreeSet ：  可以对Set集合中的元素进行排序。是不同步的。判断元素唯一性的方法：就是根据比较方法结果是否返回0，是0就是相同元素，不会再存储。在每添加一个元素的时候都会去判断。

哈希算法：
其实底层存的也是类似于Array这样的，只不过查找的时候特别快，因为查找的时候，直接根据元素就能找到位置。
怎么存进去呢？
流程是：来一个元素，根据hashCode，也就是AccIss码，得到一个数值，取模，如算出来的值是100，数组的长度的10，那就100%10，得到0-9之间的数。
按位置存进去。查询的时候，再用同样的算法算得位置，直接把那位置的元素拿出来。
存的时候，因为hashCode可能会把不同的元素算成相同的值（如字符串ab,和ba）。这时会先看那个位置有没有元素，如果有元素，再判断之前存的那个元素和要添加的元素是否相等。
怎么判断相等？直接用 equals方法。注意如果hashCode都不同，那第二步就不需要判断了，直接存即可。
这就使得，哈希列表，肯定不会有重复元素的。上面讲的，如果内容也完全相同，那就直接不存新插入的元素。
如果hashCode相同，内容不同（如ab和ba），则称为哈希冲突，通常不会出现这种情况，因为哈希算法不会是简单的用Acciss码来。
冲突的解决办法：顺延，把新插入元素放在之前元素后面的空位置，如果不够长度会将数组的长度延长。
另外一种是 串连，即那个位置再外挂一个出来，存新插入的元素。
查找的时候也解决了，内部这个位置会记录外挂或顺延这两种方式，得到那个重复hashCode的元素。

String这个类，本身就有hashCode()方法 和 equals()比较内容是否相等的方法。
会根据String自身的特点，进行hash算法。
自己定义的类，因为是继承了Object，也会有hashCode方法和equals方法，如人类，里面有姓名和年龄，
如果想只根据姓名来判断是同一个人，可以重写父类Object的hashCode方法和equals方法。
Object父类的hashCode方法，是native 这个修饰符修饰的，代表着他底层是调 原生态方法，方法对应的实现不是在当前文件，而是在用其他语言（如C和C++）实现的文件中

**** 重点注意：：：
数据结构不一样，判断元素是否相同(如a.contains(b)和 remove(b))【remove的时候也得先去查找，再删除】 等也不相同：
如ArrayList，他们判断元素相同只是判断 equals这个方法，如默认是判断地址是否相同，可以重写这个方法，来如按姓名和年龄，他们两相同，就可以认为是同一人，不用管地址。
如HaseSet，他就必须同时hashCode相同和equals相同，才是真的相同。
   当然也可以重写他们，如hashCode里自定义算法，如返回的hash值是 return 姓名.hashCode()+age*40 这样的算法。[注意，姓名.hashCode()这是字符串的hashCode，可不是本对象中的]


|----  HashSet 是无序的，不能重复的。
如果我们想要有顺序，可以用HashSet的子类： LinkedHashSet 。就是在HashSet 原有算法、存储 的基础上，再记录了下个元素的位置，做到了有序。
使用和HashSet完全相同： LinkedHashSet是和存储一致的顺序
HashSet hs = new LinkedHashSet();

|-- TreeSet集合也是Set接口里的子类：
他和HashSet不一样，人根本就不看Hashcode，他只看   自己定义的类实现 Comparable接口，实现的方法CompareTo
判断元素唯一性的方法：就是根据比较方法结果是否返回0，是0就是相同元素，不会再存储。在每添加一个元素的时候都会去判断。
这个方法需要在里面比较元素的大小，添加的时候就要，因为那如果不判断，返回0，其他的元素就添加不进去。实现了这个方法，在添加的时候，他就有序了。

// 覆盖比较方法，先比较年龄，再比较姓名。Person类，需要实现Comparable接口，并重写compareTo方法。是写在实体类上的。
@Override
public int compareTo(Object o) {
    int temp = this.age - s.age;
    return temp == 0 ? this.name.compareTo(s.name) : temp;
}

|-- TreeSet对元素进行排序的方式一：   在实体类上实现Comparable接口 并重写 compareTo方法
就是上面那种，让元素也就是自己定义的类，自身具备比较功能，就需要实现Comparable接口，覆盖里面的CompareTo方法。
|-- TreeSet对元素进行排序的方式二：   单独再定义一个类 实现Comparator接口并重写 compare方法
如果不要按照对象中具备的自然顺序进行排序，如果对象中不具备自然顺序。如果这个对象根本就不是我们定义的。怎么办？可以使用TreeSet集合的第二种排序方式：
----- 让集合自身具备比较功能。也就是在集合创建的时候，在构造函数里传入一个比较器 Comparator
/**
 * 比较器，需要实现Comparator接口
 */
class ComparatorByName implements Comparator{

    @Override
    public int compare(Object o1, Object o2) {
        Student s1 = (Student) o1;
        Student s2 = (Student) o2;

        int temp = s1.getName().compareTo(s2.getName());
        return temp == 0 ? s1.getAge() - s2.getAge() : temp;
    }
}
如果方式一和方式二都存在了，则以比较器为准，也就是方式二。推荐使用比较器Comparator。怎么用呢？
比如  TreeSet ts = new TreeSet(new ComparatorByName());    在构造方法里传进去，这个ts对象就已经有可比较性了。

|-- TreeSet底层的结构：：二叉树
二叉树怎么提高效率？利用二分折半查找，因为二叉树放完两个元素，他们就已经把顺序排了，再排第10个的时候，前9个已经有顺序了，所以可以用二分法折半查找。



=======================================================================================================================
|--------- 集合框架中，与Collection 同样的顶级 容器， Map
Map一次添加一对元素，Collection一次添加一个元素。
Map也称双列集合，Collection是单列集合。
Map集合中存储的就是键值对。必须保证键的唯一性。
Map集合是无序的。

|-常用方法：
1、添加
value返回值 put(Object key, V value)   // 添加，如果key已经存在，则会新value覆盖原来的值，并返回原来的value，如果不存在则返回null

2、删除
void remove(Object key)   // 删除一个元素
value返回值 clear();   // 移除所有映射关系，返回那个删除的元素

3、判断
boolean containsKey(key);
boolean containsValue(value);
boolean isEmpty();

4、获取
value返回值 get(Object key)   //通过键返回value，如果不存在 返回null，当然可以通过返回null来判断是否包含指定键。
int size()   // 获取键值对的个数
Collection<T> values()   // 取出所有的vlue。values返回Collection，为啥不返回set呢？因为值是不唯一的，而key是唯一的，所以只能返回Collection
Set keySet()    // 取出所有的key
Entry entrySet()   // 取出所有的k,v放入到Entry这种类型的Set中。

##### 取出map的所有元素：
// 方法1：  keySet 可以理解成 丈夫的合集
// 通过keySet方法获取 map中所有的 key 得到set集合,通过set的迭代器获取到每一个键，再对每一个键通过map集合的get方法获取其对应的值即可
Set keySet = map1.keySet();
Iterator it = keySet.iterator();
while (it.hasNext()) {
    System.out.println(map1.get(it.next()));
}

// 方法2：entrySet 可以理解成结婚证书的合集
// 通过Map转换成Set就可以迭代，entrySet方法将键和值的映射关系作为对象存储到Set集合中，而这个映射关系的类型就是Map.Entry类型(结婚证)
Set<Map.Entry<Integer, String>> entries = map1.entrySet();
Iterator<Map.Entry<Integer, String>> it1 = entries.iterator();
while (it1.hasNext()) {
    Map.Entry<Integer, String> en = it1.next();
    System.out.println(en.getKey()+1+"--"+en.getValue());
}

// 只要map里元素的值，不要key，vlues返回Collection，为啥不返回set呢？因为值是不唯一的，而key是唯一的，所以只能返回Collection
System.out.println(map1.values());


|------------- Map常用的子类：
|--HashTable   内部结构是哈希表，是同步的，因为jdk1.0就有了，不支持Null作为键和值。
    |--Properties  用来存储键值对型的配置文件的信息。和IO技术结合才能发挥最大的作用。他是HashTable里的子类。

|--HashMap     内部结构是哈希表，不是同步的。允许null作为键和值。Set集合里的HashSet是HashMap的一个实例。
    |--LinkedHashMap   链表结构的哈希表，有序的。
|--TreeMap     内部结构是二叉树，不是同步的。可能对Map集合中的键进行排序。他是有序的是，与TreeSet一样。





=======================================================================================================================
java中，只要用到了带有<>的类或者接口，就要明确传入的具体引用数据类型
泛型技术是给编译器使用的技术，用于编译时期，确保了类型的安全。
运行时，会将泛型去掉，因为生成的class文件中是不带泛型的，这个称为泛型的擦除。
为什么擦除？因为为了兼容运行的类加载器。
泛型的补偿：在运行时，通过获取元素的类型进行转换动作。不用使用者再强制转换。

|--- 泛型类、泛型方法、泛型接口：：：：：：：
将泛型定义在类上，全类通用。
如果想在方法上再定义一个泛型。可以再定义：(泛型必须放在返回值前面，修饰符后面，参与静态方法的泛型定义)
public class Student<T>{
    T stu;
    public <W> void show(W str){}
    public void show1(T str){}
    // 当方法是静态的时，不能访问类上定义的泛型。如果静态方法想用泛型，只能定义在方法上。
    public static <T> void show2(T str){}
}
|-泛型接口：
interface Inter<T>{
    public void show(T t);
}
|-实现泛型接口：
class InterImpl implements Inter<String>{
    public void show(String str){}
}

|- 泛型的通配符：  符号来通配。? 也就是未知类型
如  public static void printCollection(Collection<?> col) {}  传过来的参数可以是任意类型。
这个在 containsAll(Collection <?> c) 方法中用的比较多，因为比较，是用equals，任何类型都有equals方法，字符串也可以和对象进行比较。
还有 removeAll(Collection<?> c) 中也是这样用。他们原理一样，先用equals 找出与后面传过来相同的东西，再操作删除。

|- 泛型的上限：    ? extends E  接收E类型或E的子类型对象。
public static void printCollection(Collection<? extends Person> col) {
    Iterator<? extends Person> it = col.iterator();
    while (it.hasNext()) {
        Person p = it.next();
        System.out.println(p.getName()+"--"+p.getAge());
    }
}
|- 泛型的下限： ? super E     接收E类型或E的父类型，下限。
一般存的时候，用上限，如List集合里有  addAll方法，传一个集合进去，批量添加。那时可以在参数上加个 上限的泛型。
因为这样，取出都是按照上限的类型来运算的，不会出现类型安全隐患。

// ---------------------------------------------------------------------------------------------------------
集合 大家庭：
|-Collection
  |-List
    |-ArrayList
    |-LinkedList
  |-Set
    |-HashSet
      |-LinkedHashSet
    |-TreeSet
|-Map
  |-HashMap
    |-LinkedHashMap
  |-TreeMap

集合的一些技巧：
需要唯一吗？
 |-需要  找set
   |-需要顺序吗？
     |-需要  找TreeSet
     |-不需要  HashSet
      但是想要一个和存储一致的顺序（有序）：LinkedHashSet
 |-不需要  找List
   |需要频繁增删吗？
     |-需要：LinkedList
     |-不需要：ArrayList

如何记录每一个容器的结构和所属体系？  看名字
List
  |-ArrayList
  |-LinkedList
Set
  |-HashSet
  |-TreeSet
后缀名就是该集合所属的体系。前缀名就是该集合的数据结构。

看到array，就要想到数组，就要想到查询快，有角标。
看到link，就要想到链表，就想想到增删快，就想想到add get remove等 + first last的方法。
看到hash，就要想到哈希表，就要想到唯一性，就要想到元素需要覆盖hashCode方法和equals方法。
看么tree，就要想到二叉树，就要想到排序，就要想到两个接口Comparable,Comparator。
而且通常这些常用的集合都是不同步的，线程不安全的，效率高。

排序和有序的区别：
如LinkedHashSet 是有序，怎么存进去怎么取出来。
而TreeSet是排序，他还是无序的，只不过按我们指定的顺序给排出来的，并不代表他存的时候就是那个顺序。
如存进去的时候是：
HashMap map = new HashMap();
map.put(7, "a");
map.put(1, "b");
输出的时候是1，7输出，这代表是无序的，只不过结果里是按key的大小来排列的。
HashMap map = new LinkedHashMap();
再执行上面的put方法，得出的结果是  7,1，这是有序的，怎么存进去怎么取出来。



=======================================================================================================================
工具类：Collections、Arrays
Collections.sort(list);  //把list里的元素按自然顺序 进行升序排序
Collections.sort(list, Comparator c);  // 按指定的 比较器 进行排序
Collections.swap(list, int i, int j);  //把list的i和j位置交换元素
Collections.binarySearch(list, 元素);   //使用二分法折半查找，这个要求先用sort排序完再找。返回索引号
Collections.max(list) 和 Collections.max(list)  取集合的最大 最小值
Collections.reverseOrder()    // 返回逆序构造器，可直接用于构造方法中作为参数传进去。
  以前在创建TreeSet的时候，需要强制的有比较器（要么new的时候传比较器进去，要么添加的元素所在的类自己实现了Comparable接口）。这个方法就不用那么麻烦，
  在TreeSet new的时候，构造方法里，传这个 进去。如 TreeSet ts = new TreeSet(Collections.reverseOrder());
  所有的集合都可以用他   如  Collections.sort(list, Collections.reverseOrder()); 这是指定逆序来排列
Collections.reverseOrder(已有的比较器)    // 把已有的比较器的结果进行逆转。
Collections.reverse(list)     //对结果进行反转。
Collections.replaceAll(list, oldVal, newVal)   // 旧元素替换为新元素
Collections.fill(list, val)   // 把list里的所有元素都换成 val这个元素
Collections.shuffle(list)   // 随机洗牌随机排序
Collections.synchronizedCollection(collection)   // 返回同步的线程安全的collection
Collections.synchronizedList(list)   // 返回同步的线程安全的List
Collections.synchronizedMap(map)  // 返回线程安全的Map
Collections.synchronizedMap(Set)  // 返回线程安全的Set
Collections.toArray()      // 集合转为数组，会返回Object类型的数组。还有一个带参数的toArray方法，那返回 参数中 指定类型的数组。如 Collections.toArray(new String[2]);
                              集合变数组后，不允许增删，长度不能变。如果不想别人对你的数字进行增删，那就返回一个数组给别人。
                              toArray方法需要传入一个指定类型的数组的时候：长度如何定义？
                              如果长度小于集合的size，那么该方法会创建一个同类型并和集合相同的数组。
                              如果长度大于集合的size，那么该方法会使用指定长度的数组，存储集合中的元素，其他位置默认为null
                              所以建议，长度就指定为集合的size。如：
                              Collections.toArray(list, new String[list.size()]);



Arrays.binarySearch(arr, key)    //二分查找
Arrays.copyOf()   // 复制
Arrays.copyOfRange(arr, int form, int to)  // 复制指定的位置长度到指定的新数组
Arrays.equals(arr1, arr2)   // 两数组是否相等
Arrays.deepEquals(arr1, arr2)   // 数组比较，不仅比较内容，还进行深度的比较
Arrays.fill(arr, key)   // 替换所有元素
Arrays.hashCode(arr)   // 算指定数组的哈希值
Arrays.sort(arr)    // 排序
Arrays.toString(arr)    // 转为字符串，用于打印，因为如果直接打印数组，是出来哈希值，调用这个方法就会出现字符串。
Arrays.asList(arr)   // 把数组转为List集合，好处就是可以用集合的方法操作数组。注意数组的长度是固定的，用集合的方法不能改变他的长度，比如不能add/clear/remove
                        如果数组中的元素是对象，asList会将数组中的元素转为集合中的元素存储
                        如果数组中的元素是基本数据类型，如int，那么会将数组作为集合中的元素进行存储。所以这个数值数组是一个整体，转成集合后，集合里只有一个元素，就是数值数组。



########################################################################################################
###################### jdk1.5 高级特性
########################################################################################################
|- 增强型 for 适合迭代器操作：（它只适合遍历 数组 或 单列集合，不能遍历Map这样的双列集合，但是可以遍历Map里的keySet和EntrySet）
Iterator it = list2.iterator();
while (it.hasNext()) {
    System.out.println(it.next());
}
等价于：
// 高级for只用于遍历和迭代，不会对元素进行过多的操作。
for (String s:list2){
    System.out.println(s);
}

// 高级for  遍历Map里的keySet和EntrySet
Map<String, String> map = new HashMap<>();
for (String key:map.keySet()){
    System.out.println(key+"--"+map.get(key));
}
for (Map.Entry<String, String> en:map.entrySet()){
    System.out.println(en.getKey()+"--"+en.getValue());
}

|- 可变参数：  必须定义在参数列表的结尾处，而且只能用一个可变参数
public static void method1(String... arr){
    System.out.println(Arrays.toString(arr));
}
method1();
method1("abc1", "abc12", "abcd3");

|- 静态导入
如： 使用工具类 Collections和Arrays。每次用的时候，都是都需要写这两个单词。
import static java.util.Collections.sort;
导入这个，注意需要是静态的 static
以后再书写就只需要写   sort(list);了，不就用  Collections.sort(list);
import static java.util.Collections.*;  // Collections包里的所有的都静态导入



########################################################################################################
###################### 其他对象、Api、工具
########################################################################################################
|- System(java.lang包下)  它是final类型的类，不允许被实例化，里面的方法和属性都是静态的。以下三个是它的字段
  |- System.out  输出流
  |- System.in   输入流
  |- System.err  错误输出流
常用方法：
long System.currentTimeMillis()   // 毫秒数，相对于1970年1月1日
System.getProperties()  //获取当前系统的属性信息，返回Properties集合[继承自HashTable,也就是Map的子类]
  |- Properties集合中存储的都是String类型的键值对，最好使用他自己的存储和取出方法来完成元素的操作。
     有方法 |- setProperty(String key, String value);  设置键值
           |- stringPropertyNames()   返回此集合中的键集。
           |- getProperty(String key)  获取值

代码展示 Properties集合
// Properties集合，继承自HashTable，继承自Map双列集合
Properties pro = System.getProperties();
// 获取里面所有的key
Set<String> keySet = pro.stringPropertyNames();
for (String str : keySet) {
    // 根据key找value
    System.out.println(str+"："+pro.getProperty(str));
}

### 好用的地方：比如在windows下和linux下，换行符不一样，windows是 \n，linux是 \r
所以可以今后写换行的地方，这样写：
System.out.println("Hello"+System.getProperty("line.separator")+"world");
也可以把它抽出来放在静态常量里：
private static final String LINE_SEPARATOR = System.getProperty("line.separator");
System.getProperties() 这里可以获取当前项目的classpath，是在当前项目的bin目录下。
System.setProperty("myclasspath", "/wordcount/input/bin");   设置自己的属性到系统属性中。这些信息是全局的，其他程序都可以使用。


|- Runtime 运行时类，通过 getRuntime()来获取当前运行时对象。它是单例的。
这个类没有构造方法，说明它不能创建对象。又有非静态方法，说明该类提供了静态的返回该类对象的方法。
而且只有一个方法，说明Runtime类使用了单例设计模式。

## 实例化 Runtime是java.lang包下的
Runtime r = Runtime.getRuntime();
## 调用本地程序  如打开记事本，返回Process 进程号，返回Process类。
r.exec("notepad.exe");
// 运行记事本，并解析一个文件。如打开播放器，加空格指定影片的位置，会打开播放器的同时播放那个电影。
Process p = r.exec("notepad.exe C:\\sys001.log");
Thread.sleep(5000);
// 杀掉这个进程，只能杀自己开的，非自己开的不能杀
p.destroy();

|- Math (java.lang包下) 数学类
常量：：：
Math.PI    3.1415926
方法：：：
Math.ceil(12.56);  返回大于参数的最小整数
Math.floor()   返回小于参数的最大整数
Math.round()   四舍五入后的整数
Math.max(3, 4)  返回比较的大值
Math.pow(a, b)  返回第a的b次方。
Math.random()   返回0(包含0)，到1(不包含)之间的小数，如0.4323432333356
想生成1到10的整数： 两种方法
double d = Math.ceil(Math.random()*10);
double d1 = (int)(Math.random()*10+1);
通过Random类来随机：：
Random r = new Random();
r.nextInt(10);   返回最多为10，不包括10，的整数。包括0，最小为0


|- Date 日期(java.util.Date包)
日期对象初始化：
两个构造方法，一个是带参数的，一个是不带参数的。
带参数是毫秒值，返回那个时间的日期。不带参数是当前时间的日期。

毫秒值 转为 日期对象：
1、通过Date对象的构造方法  new Date(timeMillis);
2、通过Date对象的方法设置  date1.setTime(timeMillis);
可以通过Date对象的方法对该日期中的各个字段如年月日等进行操作。

日期对象 转为 毫秒值：【可以通过具体的数值进行运算 如 加10000毫秒】
1、date1.getTime() 方法

其他方法：
date1.compareTo(Date date2)  // 比较两日期，返回int类型，与String等比较一致
date1.equals(Date date2)     // 两日期是否相等
date1.toString()     把日期按这种格式显示  星期几 几月 几号 时分秒 时区 年

|- 日期格式化：  SimpleDateFormat (java.text.SimpleDateFormat 包)
它是 DateFormat的子类。下面这两种方式是 用 DateFormat来格式化：
DateFormat df = DateFormat.getDateInstance(DateFormat.LONG);
System.out.println(df.format(date2));
DateFormat df1 = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG);
System.out.println(df1.format(date2));

这样很麻烦，他提供了 SimpleDateFormat子类：：：
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
String date_str = sdf.format(date2);  // 转为指定格式的字符串了
Date date3 = sdf.parse(date_str);     // 把指定格式的字符串 转为日期

|- Calendar 日历类 (java.util.Calendar 工具包)
创建日历类：
Calendar cal = Calendar.getInstance();

// 设置年
cal.set(Calendar.YEAR, 2019);

// 加两年,减2年是 -2
cal.add(Calendar.YEAR, 2);
cal.add(Calendar.DAY_OF_MONTH, -2);  // 减两天

// 获取年月日星期
int year = cal.get(Calendar.YEAR);
int month = cal.get(Calendar.MONTH)+1; // 这样获取会比当前真正月小1，需要加1
int day = cal.get(Calendar.DAY_OF_MONTH);
int week = cal.get(Calendar.DAY_OF_WEEK); // 老外的星期日是1，星期一是2

// 获取当前是第多少周
cal.getWeeksInWeekYear()




########################################################################################################
###################### IO (Input Output) 流
########################################################################################################
|-输入流和输出流：：：
输入流和输出流是相对于内存设备而言，将外设中的数据读取到内存中，就是输入(读)；
将内存中的数据写入到外设中，就是输出(写)。
硬盘的数据放到内存中计算，是输入，输入就是读。
内存中的数据写到到硬盘中，是输出，输出就是写。

|-按操作数据类型不同  分两类：
字节流     // 计算机里的一切都是字节，字节流 可以处理一切数据
字符流     // 知识：编码表：美国ascii码表,中国GB2312 GBK,国际组织unicode码表。
字符流的由来，就是 字节流 读取文字字节数据后，不直接操作，而是先查指定的编码表，获取对应的文字。
再对这个文字进行操作，简单的说：就是   字节流 + 编码表

|-四个顶层基类
字节流的2个顶层抽象基类   1、InputStream        2、OutputStream
字符流的2个顶层抽象基类   1、Reader(读、输入)    2、Writer(写、输出)
这些体系的子类都是以父类名作为后缀。而且子类名的前缀就是该对象的功能。

如果要操作文字数据，建议优先考虑字符流。
而且将数据从内存写到硬盘上，要使用字符流中的输出流 Writer
硬盘的数据基本体现是文件，希望找到一个可操作文件的Writer。就是FileWriter。

|- FileWriter 写文件
private static final String LINE_SEPARATOR = System.getProperty("line.separator");
/*
创建一个可以往文件中写入字符数据的字符输出流对象
既然是往一个文件中写入文字数据，那么在创建对象时，就必须明确该文件(用于存储数据的目的地)
如果文件不存在，则会自动创建。
如果文件存在，则会被覆盖，也就是先删掉再创建。
构造函数里可以指定第二个参数，是否追加写入，默认是覆盖。
* */
FileWriter fw = new FileWriter("demo1.txt", true);
// 调用 write 方法 ，数据会被临时存储，写入到了临时存储缓冲区中。
fw.write("sf"+LINE_SEPARATOR+"sbbb");
// 进行刷新，将数据从缓冲区 写到目的地中。
//fw.flush();
// 关闭流关闭资源，关闭之前，会自动调用flush()
fw.close();

|-FileReader 读取文件
/**
 创建读取字符数据的流对象。
 在创建读取流对象时，必须要明确被读取的文件。一定要确定该文件是存在的
 用一个读取流 关联一个已存在的文件。
 读文件的过程：本质上是一次读一个字符，只不过用char[] buf = new char[1024]，
 是把一次读一个字符，先放在这个数组里，等这个数组满1024，或者读到 -1 代表读完了。
 再把这个char[] 字符数组转为 字符串。完成读取过程。
 read方法，不带参数是一次取一个字符。如果带参数是指一次读取一个字符数组的字符。(本质也是一个一个读)
 */
FileReader fr = new FileReader("demo1.txt");
// 使用read(char[])读取文本文件数据，一般这数字就是1024，因为存储时就是按这大小来存的。
char[] buf = new char[1024];
// 将读到的字符存储到数组中，返回读取到的字符数量。
int len = 0;
while ((len = fr.read(buf)) != -1){
    System.out.println(new String(buf, 0, len));
}

|-复制文件
// 练习：复制c盘的文本文件到d盘
// 思路就是先读取出源文件，再写入到目标文件。既然是操作文本文件，使用字符流
// 读数据
FileReader fr = new FileReader("c:\\sys001.log");
// 写数据
FileWriter fw = new FileWriter("c:\\sys001_copy.log");
// 创建一个临时容器，用于缓存读取到的字符。
char[] buf = new char[1024];
// 定义一个变量记录读取到的字符数，其实就是往上面那个数组里装的字符个数，他大小是1024，可能本次只装了20
int len = 0;
while ((len = fr.read(buf)) != -1) {
    // 这个得只能写0到len，不然会把1024这个字符数组都写进去了，很多空格。
    fw.write(buf, 0, len);
}
// 关闭流
fw.close();
fr.close();

|-缓冲区：java提供了两个缓冲区，缓冲读java.io.BufferedReader  缓冲写java.io.BufferedWriter
缓冲区就是对要操作的内容进行临时缓存，提高效率。
他里面有个好方法： 对象.newLine();   写入一个换行符，适应不同平台。

缓冲 BufferedWriter 代码
----------------------------------------------------------------------------
FileWriter fw = new FileWriter("buf.txt");
// 为了提高写入的效率使用字符流的缓冲区。
// 创建一个字符写入流的缓冲区对象，并和指定要被缓冲的流对象相关联
BufferedWriter bw = new BufferedWriter(fw);
// 使用缓冲区的写入方法，他的方法与Writer完全相同
bw.write("abc");
bw.newLine();
bw.write("def");
// 使用缓冲区的刷新方法将数据刷新到目的地。一定要刷新，write一次刷新一次。
bw.flush();
// 关闭缓冲区，其实关闭的就是缓冲的流对象。关了缓冲区以后，文件的流也就关闭了。
bw.close();


缓冲 BufferedReader 代码
----------------------------------------------------------------------------
文本类型的流特有的：可以一次读取一行。（根据回车符判断是否换行）。里面提供了 readLine() 方法。
FileReader fr = new FileReader("buf.txt");
BufferedReader br = new BufferedReader(fr);
String line = null;
// 最后一行，如果不存在，返回null
while ((line = br.readLine()) != null){
    System.out.println(line);
}
br.close();
BufferedReader 的 read()方法，是从缓冲区里读，覆盖了他父类的read()方法，他父类是从硬盘上取。
这个read()方法很高效。也可以传一个字符数组参数进去一次读到字符数组中。
readLine()取的数据，是取一行，他的原理与read()一样，一个一个读，只不过读到换行符就终止并返回，
返回的只是字符数据，不包括换行符。如读完了，则返回null。


NumberLineReader(用到行号时才用他)  是BufferedReader 的子类，也是装饰，他增加的功能就是 能获取和设置 当前的行号。
----------------------------------------------------------------------------
FileReader fr = new FileReader("buf.txt");
LineNumberReader br = new LineNumberReader(fr);
// 设置行号从哪开始
br.setLineNumber(100);
String line = null;
while ((line = br.readLine()) != null) {
    System.out.println(br.getLineNumber()+":"+line); // 获取行号
}


装饰设计模式：   外观改变，本质实际没改变。
----------------------------------------------------------------------------
设计模式是用来解决问题的。
它是对一组对象的功能进行增强时，就可以使用该模式进行问题的解决。下面的NewPerson就是对Person的增强，装饰。
其实上面的 输入输出流和他们的缓冲区，缓冲区就是对输入输出流的 装饰。
public class PersonDemo {

    public static void main(String[] args) {
        Person p = new Person();
        NewPerson np = new NewPerson(p);
        np.eat();
    }

}

class Person{
    void eat(){
        System.out.println("吃饭");
    }
}

class NewPerson{
    Person p;
    NewPerson(Person p) {
        this.p = p;
    }

    void eat(){
        System.out.println("甜点");
        p.eat();
        System.out.println("水果");
    }
}
继承也能达到这种效果，为啥不用继承？要用装饰呢？因为装饰更灵活，因为他可以对一组(如父类)进行增强。而继承只能继承具体的一个类，
有一个类要增加就继承他一下，但是一组的怎么解决？他又不能继承父类，继承父类，那子类就用不上。而装饰可以。

装饰比继承灵活。
装饰类和被装饰类 都必须所属于同一接口或父类。被装饰类可以是那个父类，一装饰，本父类下的所有类都能用。


----------------------------------------------------------------------------
字节流 byte
----------------------------------------------------------------------------
----------------------------------------------------------------------------
字符流的缓冲区的数组是 char 字符。对一个中文字，字符流一次就能读出来。而字节流需要2次才能读出来。
字节流的缓冲区的数组是 字节 byte

|- 输出流（内存到硬盘，也就是写数据）
----------------------------------------------------------------------------
// 创建字节输出流对象，用于操作文件
FileOutputStream fs = new FileOutputStream("bytestream.txt");
// 写数据，直接写入到了目的地中，所以不需要flush也就是不需要缓冲。缓冲区Buffer才会用到flush方法。
fs.write("abc".getBytes());
// 需要完成资源关闭
fs.close();

|-输入流（硬盘到内存，也就是读数据）
----------------------------------------------------------------------------
// 创建读取流对象，和指定文件关联。
FileInputStream fs = new FileInputStream("bytestream.txt");
// 这叫自定义缓冲区   一次读取一个缓冲区数组大小的数组
byte[] buf = new byte[1024];
int len;
while ((len = fs.read(buf)) != -1){
    System.out.println(new String(buf, 0, len));
}

另外一种方式，主要是用到了他里面的 获取文件字节大小的方法 available()
// 输出流的新读取方式
// 获取文件的字节数(英文只占一个字节，中文占两个)  fs.available()
byte[] buf = new byte[fs.available()];
fs.read(buf);
System.out.println(new String(buf));

fs.close();


|- 输出流 缓冲区
// 创建字节输出流对象，用于操作文件
FileOutputStream fs = new FileOutputStream("bytestream2.txt");
BufferedOutputStream bs = new BufferedOutputStream(fs);
// 写数据，直接写入到了目的地中，所以不需要flush也就是不需要缓冲。缓冲区Buffer才会用到flush方法。
bs.write("abc".getBytes());
// 缓冲区需要flush
bs.flush();
// 关闭缓冲区
bs.close();



键盘输入输出：
----------------------------------------------------------------------------
键盘本身就是一个标准的输入设备，java对于这种输入设备都有对应的对象。在System类(java.lang)中。
InputStream in = System.in;
这个 in 最好不要close，因为他是随着系统消失而消失，随着系统来而来。
默认的输入输出设备都不需要关。如键盘和控制台。

StringBuffer和StringBuilder是两个字符串容器。
OutputStream os = System.out; //实际上他是 PrintStream类。
System.in 和 System.out 都是字节流。要输出为文本，都需要转换器转换成字符流。

键盘录入代码：
----------------------------------------------------------------------------
// 字节流
InputStream is = System.in;
int ch = 0;
while ((ch = is.read()) != -1) {
    System.out.println(ch + "--" + (char) ch);
}
// 这个标准输入输出流不需要关闭，会随着系统关而关，它只有一个，关了就没了。
//is.close();


把字节流 转为 字符流：
----------------------------------------------------------------------------
练习：键盘输入字符，回车后转为大写，当输入了over以后，结束输入:

// 字节输入流
InputStream is = System.in;
// 字节流转为字符流的转换器，他是字符流的子类，也是装饰类
// 如果是中文，占两个字节，所以如果直接用System.in输入中文一个字，会返回两个字符。
// 而通过字符流输入一个中文汉字，他会去编码表里查表，查到后返回一个字符编码。
InputStreamReader ir = new InputStreamReader(is);
// 缓冲区
BufferedReader br = new BufferedReader(ir);
String line = null;
while ((line = br.readLine()) != null) {
    if ("over".equals(line)) {
        break;
    }
    System.out.println(line.toUpperCase());
}


// 字节输出流 转为 字符输出流
// 字符转字节
InputStream is = System.in;
// 字节流转为字符流的转换器
InputStreamReader ir = new InputStreamReader(is);
// 输入缓冲区
BufferedReader br = new BufferedReader(ir);

// 输出 字节流，输出到标准控制台。
OutputStream os = System.out;
// 这是为了把 最终显示到控制台的 字节流 转字符流。
// 之前学过的FileWriter 是这个转换流的子类。所以写文件的时候不需要再转换一次，字节直接就以字符的方式写到文件了。
OutputStreamWriter ow = new OutputStreamWriter(os);
// 输出缓冲区
BufferedWriter bw = new BufferedWriter(ow);

String line = null;
while ((line = br.readLine()) != null) {
    if ("over".equals(line)) {
        break;
    }
    bw.write(line.toUpperCase());
    bw.newLine();
    // 刷新才会显示出来
    bw.flush();
}


简化代码  上面那么多行，省成下面这几行：
----------------------------------------------------------------------------
BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));
BufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(System.out));
// 如果想不写到控制台，而是输出到文件中，只要修改上面那一行代码：BufferedWriter bufw = new BufferedWriter(new FileWriter("abc.txt"));
//或者：BufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream("abc.txt")));
// 如果想从文本文件读内容写到控制台： 改一行  BufferedReader bufr = new BufferedReader(new InputStreamReader(new FileInputStream("abc.txt")));

String line = null;
while ((line = bufr.readLine()) != null) {
    if ("over".equals(line)) {
        break;
    }
    bufw.write(line.toUpperCase());
    bufw.newLine();
    // 刷新才会显示出来
    bufw.flush();
}

转换流：
----------------------------------------------------------------------------
InputStreamReader  字节到字符的桥梁，解码
OutputStreamWriter  字符到字节的桥梁，编码。
流的操作规律：
之所以要弄清楚这个规律，是因为流对象太多，开发时不知道用哪个对象合适。
想要知道开发时用到哪些对象，只要通过四个明确即可：
1、明确源和目的(汇)
    源：InputStream   Reader
    目的：OutputStream   Writer
2、明确数据是否是纯文本数据。
    源：是纯文本：Reader   否：InputStream
    目的：是纯文本：Writer   否：OutputStream
    到这里就可以明确需求中具体要用哪个体系。
3、明确具体的设备：
    源设备：
        硬盘：File
        键盘：System.in
        内存：数组
        网络：Socket流
    目的设备：
        硬盘：File
        控制台：System.out
        内存：数组
        网络：Socket流
4、是否需要其他额外功能。
    4.1、是否需要高效（缓冲区）：加Buffer
    4.2、转换。(字节流转字符流，字符流转字节流)


字符编码的问题：
----------------------------------------------------------------------------
java中字符用unicode码，中文用gbk码。全世界通用，两个字节表示全世界的文字。
如果是a,b这种字符，会在他前面加上 8个0，最后是全世界两位。
由于2个字节来装，太占空间了，后来产生了utf-8编码，有几个就占几个。

直接操作 FileWriter,FileReader就有缺陷，他们不能指定编码，只能用操作系统默认的编码如gbk。
所以需要转换器，OutputStreamWriter, InputStreamReader。他们可以指定编码。
他们的构造函数里 第二个参数可以指定编码。
字符流 FileWriter和 FileReader 其实，是对 转换器 进行了一层封装，也就是说：
new FileWriter("a.txt")  <===>   new OutputStreamWriter(new FileOutputStream("a.txt"));
这两个等价。

但是 后者可以指定编码：
new OutputStreamWriter(new FileOutputStream("a.txt"), "utf-8");
用utf-8以后，文件的大小就会节省。一个文件他的大小，就是这个字符数来算的，如有10个英文字符，他的大小就是10个字节。
字符流那Reader类FileReader，可以用char[] 来read()。
字节流那Reader类FileIntream，只能用byte[] 来read()。

什么时候使用转换流：？
1、源或目的对应的设备是字节流，但是操作的却是文本数据，可以使用转换作为桥梁，提高对文本操作的便捷。
2、一旦操作文本涉及到具体的指定编码表时，必须使用转换流。



----------------------------------------------------------------------------
------------ File  (java.io.File包)
----------------------------------------------------------------------------
可以将一个已存在的，或者不存在的文件或目录封装成file对象。
创建流的时候，可以直接传一个File对象进去。如 FileReader fr = new FileReader(new File("abc.txt"));
这样的话，如果先读后写的时候，可以都共用同一个对象，而且还可以判断如果这个文件不存在先创建他。

|-构造函数
File file = new File("abc.txt");
File file1 = new File("c:\\","abc.txt");
File file2 = new File("c:\\");
File file3 = new File(file2, "abc.txt");

|-字段
// 路径分隔符 File.pathSeparator，如 unix是: windows是; 主要是在环境变量里用。
// 文件分隔符 File.separator
System.out.println(File.separator);
System.out.println(File.pathSeparator);

|-常见方法：
1、获取
    1.1获取文件名称   file.getName()
    1.2获取文件路径   file.getAbsolutePath()绝对路径   file.getPath()相对路径
    1.3获取文件大小   file.length()字节数   file.getFreeSpace()剩余空间
    1.4获取文件修改时间   file.lastModified() 返回毫秒数
    1.5获取父路径     file.getParent()  这个得要绝对路径创建的File才能获取到，不然返回null

2、创建与删除
    File file = new File("abc.txt");
    boolean b = file.createNewFile();
    如果已经存在，则不会再创建。和输出流不一样，输出流是如果存在则覆盖，除非指定第二个参数，指定追加。
    已存在或创建失败，则返回false，成功返回true
    ##创建目录：
    File file1 = new File("abc");
    file1.mkdir();
    ##创建多级目录：
    file1 = new File("abc\\a\\b\\c");
    file1.mkdirs();

    删除：
    file.delete();  删除成功返回true，失败false。如果文件正被流操作，也是删除不掉。
    file.deleteOnExit();  退出时删除，程序结束删除。
    file1.delete(); 删除目录，如果目录里有文件，则删除失败
    对于如果file1是 "a/b/c/d"这种多级目录，执行删除只会删最后一级。

3、判断
    文件是否存在  file.exists();
    是否是文件    file.isFile()
    是否是目录    file.isDirectory()
    是否隐藏      file.isHidden()

4、重命名
    如果路径不在一个地方，则是重命名并且移动位置到参数里指定的位置
    File file1 = new File("abc.txt");
    file.renameTo(new File("abc2.txt"));

5、listRoots  静态方法  列出所有盘符。
   File.listRoots();  得到c:\   d:\   这方法会返回File[] 文件数组，遍历出来即可。

6、空间：
    可用空间  file.getFreeSpace() 如果file是具体某个文件，这里也是返回此文件所在的盘符的可用空间
    总容量    file.getTotalSpace()
    可以给虚拟机用的空间 与 可用空间一样的数  file.getUsableSpace()

7、String[] list() 方法，返回File类当前目录下的所有文件包括文件和目录还有系统隐藏文件。
    要用list()方法，File对象中封装的必须是目录。
    如果是系统目录或隐藏目录，也会返回空。如果 file1.isHidden() 则不需要去访问。
7.1、list()方法有个重载方法：可以传个过滤器进去，过滤些自己需要的文件。比如只要.java文件。
    过滤器是个接口，FilenameFilter接口，需要实现。
    可以传个匿名类进去：
    String[] lists = file.list(new FilenameFilter() {
        @Override
        public boolean accept(File dir, String name) {
            return name.endsWith(".java");
        }
    });
7.2、listFiles() 方法  获取目录下的所有文件和目录，返回File对象。
    上面的list()方法只是返回文件名，如果想过滤隐藏文件，list()方法就不太好用了。
    需要一个返回指定目录下所有文件对象的方法：     listFiles();
    想过滤的话 过滤器接口是 FileFilter。
    File file1 = new File("d:\\");
    File[] files = file.listFiles(new FileFilter() {
        @Override
        public boolean accept(File pathname) {
            return !pathname.isHidden();
        }
    });
    for (File f : files){
        System.out.println(f);
    }

练习：深度遍历
----------------------------------------------------------------------------
// 递归遍历某目录下的所有文件和目录，以及目录里的子目录
private static void listAll(File dir) {
    File[] files = dir.listFiles();
    for (File f : files) {
        System.out.println(f);
        if (f.isDirectory()){
            listAll(f);
        }
    }
}

递归：
----------------------------------------------------------------------------
递归是函数自身直接或间接调用了自身。
一个功能被重复使用，并每次使用时，参与运算的结果和上一次调用有关，这时可以用递归来解决问题。
注意：：
递归一定要注意条件，否则容易 栈内存溢出。
还要注意递归的次数，因为次数多了，光进没有出，也容易 栈内存溢出。


Properties 集合 (java.util.Properties)
----------------------------------------------------------------------------
|------------- Map常用的子类：
|--HashTable   内部结构是哈希表，是同步的，因为jdk1.0就有了，不支持Null作为键和值。
    |--Properties
特点：
1、该集合中的键和值都是字符串类型
2、集合中的数据可以保存到流中，或者从流中获取。
通常该集合用于操作以键值对形式存在的配置文件，由于这点，它被广泛使用。
Properties是存配置信息，与它对应的是xml文件。还有一种是数据库。

方法：
setProperty(String key, String value)
getProperty(String key)
getProperty(String key, String defaultValue), 获取key对应的value，如果没有则用那默认值
stringPropertyNames()  返回所有键Set，相当于keySet
list(PrintStream out)           // 将属性列表输出到指定的输出流，一般调试时用。
store(Writer out, String comments)   //保存数据，把内存中的属性数据写入输出流如文件中，第二个参数是用来做描述的。
                                       配置文件是存在于内存中，内存一旦释放就全没了，想把它里面的内容保存到硬盘上，这就是持久化。
                                       comments是注释，会加到这个文件的第一行。
load(Reader in)   // 从流文件中加载数据到内存中
load(InputStream is) // 从流文件中加载数据到内存中

示例：
Properties prop = new Properties();
prop.setProperty("ght", "35");
prop.getProperty("ght");
// 取所有数据
Set<String> names = prop.stringPropertyNames();
for (String str : names) {
    System.out.println(str + "-" + prop.getProperty(str));
}
// 用于调试用，将属性列表输出到指定的输出流，下面这个是输出到控制台
prop.list(System.out);
// 配置文件输出到流
prop.store(new FileWriter("abc.txt"), "name+age");
prop.store(new FileOutputStream("abc.txt"), "name+age");

// 从流文件中读出配置文件，放在 属性集合里。load方法
prop.load(new FileReader("abc.txt"));
prop.load(new FileInputStream("abc.txt"));


练习：读配置文件，修改里面的数据，并保存
----------------------------------------------------------------------------
File file = new File("abc.properties");
if (!file.exists()){
    file.createNewFile();
}
FileReader fr = new FileReader(file);
Properties prop = new Properties();
prop.load(fr);
prop.setProperty("abc2", "100");

FileWriter fw = new FileWriter(file);
prop.store(fw, "love");
fr.close();
fw.close();





----------------------------------------------------------------------------
----------------------------------------------------------------------------
------------打印流 是可以直接操作输入流的       只负责目的地
----------------------------------------------------------------------------
----------------------------------------------------------------------------

PrintStream  打印流 (java.io.PrintStream)  它是OutputStream的子类
----------------------------------------------------------------------------
优势：
1、提供了打印方法可以对多种数据值进行打印。并保持数据的表示形式。
2、它不抛IOException

构造函数：接收三种类型的值：
1、字符串路径
2、File对象
3、字节输出流。

PrintStream out = new PrintStream("print1.txt");
// write方法只写最低8位，整数在内存中是占4个字节，他就是4组8位数组成，这里只取最后8位，
// 所以导致如果write(610) 会把b写进去，因为他除最后8位之外的都被忽略了。
// 把97对应的 Accis码 a 写入到文件中。
// 如果write想原样写入 97，可以 out.write((97+"sb").getBytes()) 写入字节进去。
out.write(97);
out.print(97); // 将97先变成字符 保持原样将数据打印到目的地。
out.close();


PrintWriter  打印流 (java.io.PrintWriter)  它是 java.io.Writer 类的的子类
----------------------------------------------------------------------------
tomcat往网页输出，就是用的这个类。
构造函数参数：
1、字符串路径
2、File对象
3、字节输出流   构造方法可以传第二个参数 true，代表自动刷新
4、字符输出流

BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
PrintWriter out = new PrintWriter(System.out, true);
// 第二个参数是指定是否需要自动刷新，如果自动刷新，下面不需要再写out.flush()
out = new PrintWriter(new FileWriter("abc.txt"), true);
String line = null;
while ((line = br.readLine()) != null) {
    if ("over".equals(line))
        break;

    out.println(line.toUpperCase()); // println 会自动换行，相当于原来的 newLine();而且newLine还需要输入流缓冲才能有这方法
    // 构造方法里如果是true，这行可以注释掉。
    //out.flush();
}
out.close();
br.close();




----------------------------------------------------------------------------
----------------------------------------------------------------------------
------------序列流 SequenceInputStream      只负责源 它们是InputStream的子类
----------------------------------------------------------------------------
----------------------------------------------------------------------------
它是对多个流进行合并。是表示其他输入流的逻辑串联。
需要字节的方式操作，因为他不仅可以合并文本，还可以合并媒体文件。

Vector<FileInputStream> v = new Vector<>();
v.add(new FileInputStream("java.txt"));
v.add(new FileInputStream("abc.txt"));

Enumeration<FileInputStream> en = v.elements();
SequenceInputStream sis = new SequenceInputStream(en);

BufferedOutputStream bs = new BufferedOutputStream(new FileOutputStream("abc1.txt"));
byte[] buf = new byte[1024];
int len = 0;
while ((len = sis.read(buf)) != -1){
    bs.write(buf, 0, len);
}
bs.close();
sis.close();

这里面需要传 Enumeration类型的参数进去，但是操作Enumeration特别麻烦。
我们可以用 迭代器来操作 Iterator。
Iterator 是取代了 Enumeration。
如果上面可以用迭代器，那就不需要用Vector 这种List，太低效了。
可以用ArrayList集合，然后用 工具类：
Enumeration en = Collections.enumeration(list); 转换下即可。

优化后的代码：：
List<FileInputStream> list = new ArrayList();
list.add(new FileInputStream("java.txt"));
list.add(new FileInputStream("abc.txt"));
Enumeration en = Collections.enumeration(list);
SequenceInputStream sis = new SequenceInputStream(en);
其他部分与原来一致。


练习：切片
----------------------------------------------------------------------------
src/main/java/cn/jhsoft/study/iostream/SplitFileDemo.java    把大文件切成小切片
src/main/java/cn/jhsoft/study/iostream/MergeFileDemo.java    把小切片合并成文件



ObjectOutputStream、 ObjectInputStream  对象流  （java.io包下的类）
----------------------------------------------------------------------------
对象的输入输出流，需要那对象 实现序列化接口，implements Serializable(这个称为标记接口)
ObjectOutputStream 对象有 writeObject 方法，写个对象进去
存储对象的文件名  都是   xxx.object
这个是对一些特定的对象使用，比如数据库连接对象等，他的功能仅仅是将内存上的堆内存数据放到硬盘上。
这个不会写静态的变量进去，只会写非静态的。

序列化：
ObjectOutputStream obs = new ObjectOutputStream(new FileOutputStream("abc.object"));
obs.writeObject(new Person("宫涛", 32));
obs.close();

对象反序列化：
ObjectInputStream ois = new ObjectInputStream(new FileInputStream("abc.object"));
Person p = (Person) ois.readObject();
System.out.println(p.getName()+"--"+p.getAge());
ois.close();


ObjectOutputStream、 ObjectInputStream  对象流 的 实体类：bean类：
----------------------------------------------------------------------------
###############################  transient关键字(短暂的瞬间的)  ###############################
如果非静态的变量，不想写进去到硬盘中。可以加 transient 关键词，这个词的意思是 短暂的，瞬间的。
完全不影响对象，只不过写不到硬盘上而已。
class Person{
    private transient String name;
    private static int age;
}



RandomAccessFile   随机访问文件(java.io.RandomAccessFile包)   它的父类是 java.lang.Object
----------------------------------------------------------------------------
它并不是io体系中的子类。它是 java.lang.Object下的。

特点：
1、该对象既能读，又能写。只能操作文件，包括文本文件和媒体文件。
2、该对象内部维护一个byte数组，并通过指针可以操作数组中的元素。
3、可以通过getFilePointer方法获取指针的位置，和通过seek方法设置指针的位置。
4、其实该对象就是将字节输入流和输出流进行了封装。
5、该对象的源或目的只能是文件，通过构造函数就可以看出。
6、构造函数里第一个参数是传File，第二个参数是传个mode，可以选r或者rw，也就是读和读写。
7、如果文件不存在则创建，如果文件存在则不创建，不会覆盖，其他的输出流是覆盖。

 * 随机访问文件，要求数据有规律，也就是自己知道它里面有什么。
 * 如果没规律的，此类不适用。
 * 比如知道里面存的是姓名和年龄，如果是姓名可能是都是两个字，年龄反正是int的都是占4个字节，所以无所谓多大年纪
 * 或者如果想要有规律，可以用16个字节来表示姓名，这样每个人都是16个，不够的用空格补
 * 这样就有规律了，自己就可以算出来指针的位置，可以随机地去读和写了。
 *
 * 如果是有多线程操作同一文件，那这个类就特别适合了，每个线程去写一段。可以实现多个线程同时往一个文件写数据。
 * 断点续传，也是用的它。


代码：：：
写数据：

RandomAccessFile raf = new RandomAccessFile("ab.txt", "rw");
// 往指定位置写入数据
// 如果没有指定位置，又会从0角标开始写数据。新的0角标覆盖原来的0角标，新的1角标覆盖原来的1角标。
// 其它没有覆盖到的位置的数据不会动。
raf.seek(5*13);

raf.write("陈义".getBytes());
raf.writeInt(20);
raf.close();


读数据：
RandomAccessFile raf = new RandomAccessFile("ab.txt", "r");
byte[] buf = new byte[6];   // 取6个字节，也就是中文的二个字
raf.read(buf);
System.out.println(new String(buf));
int age = raf.readInt();   // 取完上面的姓名，指针往下移，取一个整数，也就是再取4个字节，那4个字节里存的就是一个int类型的数据
// 通过seek设置指针的位置，这就叫随机访问，想从哪个位置读就从哪个位置读。
raf.seek(1*10);
// 获取当前指针所在的位置
raf.getFilePointer();
raf.close();


管道流 PipedInputStream 和 PipedOutputStream
----------------------------------------------------------------------------
输入输出可以直接进行连接，通过结合多线程使用。
输出流会一直等，等待输入流里有数据了，就会输出来。不然就一直等，会死锁。所以需要多线程。
代码参见：src\main\java\cn\jhsoft\study\iostream\PipedStreamDemo.java

两个管道(输入输出)相连：：
PipedInputStream pi = new PipedInputStream();
PipedOutputStream po = new PipedOutputStream(pi);
// 上面是通过构造方法来连接两个管道，或者通过connect方法连接两个管道
// po.connect(pi);
new Thread(new Input(pi)).start();
new Thread(new Output(po)).start();



操作基本数据类型的  流  DataInputStream、DataOutputStream
----------------------------------------------------------------------------
它是一个包装类，初始化的时候，还是要传  FileInputStream对象进去。它只是包装原来的 FileInputStream等 类

写数据：：
DataOutputStream dos = new DataOutputStream(new FileOutputStream("utf.txt"));
// utf修改版的，存进去时会自动加标头，别的人解不开，只能用他自己提供的方法去解开
dos.writeUTF("你好");
// 还提供了writeInt等一堆方法。
dos.close();

读数据：：
DataInputStream dis = new DataInputStream(new FileInputStream("utf.txt"));
String str = dis.readUTF();
System.out.println(str);
dis.close();


操作字节数组的  流  ByteArrayInputStream、ByteArrayOutputStream
----------------------------------------------------------------------------
他们都是用来   操作 源 和 目的 都是内存的对象。
操作的是长度可变的数组，从内存中来 到 内存中去。

ByteArrayOutputStream 对象，不需要关闭，关闭也无效，因为他只在内存中操作，不会操作资源。
可以使用 toByteArray()和toString()获取数据。

ByteArrayInputStream 包含一个内部缓冲区，它是操作源的，必须有源，
所以在它初始化的时候，需要传个字节数组进去。

代码：：：
ByteArrayInputStream bis = new ByteArrayInputStream("abcdefa".getBytes());
ByteArrayOutputStream bos = new ByteArrayOutputStream();

int ch = 0;
while ((ch = bis.read()) != -1){
    bos.write(ch);
}
System.out.println(bos.toString());

// 里面还有个writeTo(OutputStream out) 方法，把流写到另外一个输出流里去。
bos.writeTo(new FileOutputStream("s.txt"));

应用：：
如果源是内存的一些操作，可以单用 ByteArrayInputStream
如果目的是内存的一些操作，可以单用 ByteArrayOutputStream



操作字符数组的  流  CharArrayInputStream、CharArrayOutputStream
----------------------------------------------------------------------------
CharArrayReader cr = new CharArrayReader("abcd".toCharArray());
字符串转char数组   toCharArray();


操作字符串的  流  StringReader、StringWriter
----------------------------------------------------------------------------
StringReader sr = new StringReader("test");


编码::
----------------------------------------------------------------------------
String str = "你好";
byte[] buf = str.getBytes("utf-8");  // 编码   得到 -60-29-70-61-31-11，计算机硬盘上实际上存的就是这个，只不过记事本解析出来后，解析成了 中文，是下面这个解码的功劳
String s1 = new String(buf, "utf-8"); // 解码   把 -60-29-70-61-31-11 解成  你好
如果用utf-8编的，然后用错了用 iso8859去解的，会得到一堆 ??，这时再用iso8859去编一次，又会重新得到 -60-29等这样的数字
再用utf-8去解。还是可以解的回来。
但如果上面的换种情况，用gbk编的，用utf-8去解，会解不出来，得到??，utf-8再给他编下码成了 -17-65-67 这代表无效字符。
再用gbk解，是解不出来的。
为什么iso8859可以而utf-8不行，因为iso8859是单字节编码解码的，并且他不识别中文，所以他能还原得回来。
而utf-8他自己加工了一次，再解就解不出来。iso8859是，不做处理。所以最终能解出来。


练习：：中文截取
/**
 * 截取中文字符串
 * @param str  要截取的字符串
 * @param len 截取的长度
 */
private static String testsubstr(String str, int len) throws Exception {
    byte[] buf = str.getBytes("utf-8");

    // 记录想截取的这一段之前 有多少个负数
    int count = 0;
    for (int i = len-1; i >= 0 ; i--) {
        if (buf[i] < 0){
            count ++;
        }
    }

    // 如果负数刚好是3和3的倍数，说明截取的len刚好够中文，所以直接返回相应的长度
    if (count%3 == 0){
        return new String(buf, 0, len, "utf-8");
    }else if (count % 3 == 1){// 如果负数的数量为1个或4个，那就需要返回的结果里减掉1个长度
        return new String(buf, 0, len-1, "utf-8");
    }else{// 如果负数的数量为2个或5个，那就需要返回的结果里减掉2个长度
        return new String(buf, 0, len-2, "utf-8");
    }
}

对于utf8编码，如果是英文和数字的，是占一个字节，那它是以 用0 开头 的8位表示如 0xxxxxxx
对于中文，是3个字节，第一个字节是 1110 xxxx,第二个是 10 xxxxxx， 第三个是 10 xxxxxx
对于其它2个字节的情况，第一个字节是 110 xxxxx,第二个是 10 xxxxxx



----------------------------------------------------------------------------
------------ 网络编程  (java.net包里)
----------------------------------------------------------------------------
类InetAddress，表示互联网IP地址。  InetAddress.getLocalHost() 获取本地主机，返回IP对象。
//获取本地主机IP地址对象
InetAddress ip = InetAddress.getLocalHost();
// 获取其它主机的ip地址对象
ip = InetAddress.getByName("jd.com");
// IP地址
System.out.println(ip.getHostAddress());
// 主机名，会根据ip去解析
System.out.println(ip.getHostName());



DatagramSocket类
----------------------------------------------------------------------------
Socket是网络通信的两端。网络服务端点。网络通信就是Socket通信。
UDP传输：
java.net.DatagramSocket  既然接收也能发送
java.net.DatagramPacket  数据报包。构造方法里，要传 SocketAddress对象的构造方法，都是发送数据。


创建UDP传输的发送端：：
----------------------------------------------------------------------------
思路：
1、建立udp的socket服务。（使用DatagramSocket对象）
2、将要发送的数据封装到数据包（DatagramPacket）中。
3、通过udp的socket服务将数据包发送出去。
4、关闭socket服务。

代码：：
// 1、udp socket服务，使用DatagramSocket对象，
// 如果在这构造方法里写个端口进去，如8888，是代表以这个端口来发送，如果不指定，则随机。
DatagramSocket ds = new DatagramSocket();

// 2、将要发送的数据封装到数据包中。
String str = "udp传输演示：宫海涛";
// 使用DatagramPacket将数据封装到该对象包中。
byte[] buf = str.getBytes();
// ip 如果改为 10.12.128.255代表它是广播地址，ip在 10.12.128.1到 10.12.128.254的人都能接收到，当然是用他们的10000端口来接
InetAddress ip = InetAddress.getByName("10.12.128.161");
DatagramPacket dp = new DatagramPacket(buf, buf.length, ip, 10000);

// 3、通过udp的socket服务将数据包发送出去，使用send方法。
ds.send(dp);

// 4、关闭资源
ds.close();




创建UDP传输的接收端：：
----------------------------------------------------------------------------
思路：
1、建立udp的socket服务。（使用DatagramSocket对象）
2、创建数据包（DatagramPacket），用于存储接收到的数据，方便用数据包对象的方法解析这些数据。
3、使用socket服务的receive方法将接收的数据存储到数据包中
4、通过数据包的方法解析数据包中的数据。
5、关闭资源。

代码：：
// 1 建立udp的socket服务，并指定监控的端口
DatagramSocket ds = new DatagramSocket(10000);

// 2 创建数据包
byte[] buf = new byte[1024];
DatagramPacket dp = new DatagramPacket(buf, buf.length);

// 3,使用接收方法将数据存储到数据包中
ds.receive(dp); // 阻塞式的

// 4,通过数据包对象的方法，解析其中的数据，比如，地址，端口，数据内容
String ip = dp.getAddress().getHostAddress();// 发送端的地址
int port = dp.getPort();// 不是本服务端的端口，是发送端的端口
// dp.getLength()是数据包数据的长度，数据包自己知道
String content = new String(dp.getData(), 0, dp.getLength());
System.out.println(ip+":"+port+":"+content);

// 5,关闭资源
ds.close();



UDP练习：：：：
----------------------------------------------------------------------------
群聊聊天室：用多线程处理。代码如下：
src\main\java\cn\jhsoft\study\net\ChatDemo.java




TCP Socket类
--------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------
分两个类 不像UDP里的DatagramSocket既然接收也能发送，也就是既然是客户端用也能服务端用。
Socket类是客户端套接字   java.net.Socket
ServerSocket类是服务端套接字  java.net.ServerSocket


Tcp传输【客户端发数据到服务端】，【客户端】建立的过程：：
----------------------------------------------------------------------------
1、Socket类的两个常用构造方法：用来建立连接
new Socket(InetAddress address, int port); // 对方的IP地址和端口
new Socket(String host, int port);  // 或者这样建立，简单

2、如果连接建立成功，说明数据传输通道已建立，这个通道就是输入输出流。
专业叫 socket流，也叫网络IO流。socket流是底层建立的，不需要我们建立，它里面既有输入也有输出。
想要输入流对象或输出流对象，可以找Socket来获取。它是字节流。
可以通过 Socket对象的 getOutputStream() 和 getInputStream() 来获取字节流

3、使用输出流( getOutputStream )，将数据写出，因为是咱们自己机器写出去到网络上。
4、关闭资源。

代码：：
Socket sc = new Socket("10.12.128.161", 10000);
OutputStream outputStream = sc.getOutputStream();
outputStream.write("你好宫海涛".getBytes());
sc.close();



Tcp传输【服务端接收客户端的数据】，【服务端】建立的过程：：
----------------------------------------------------------------------------
1、Socket服务端用 ServerSocket类。它的构造方法：
new ServerSocket(10000); //指定端口号
2、获取连接过来的客户端对象。(可能很多客户端连过来，本次处理的是哪个？3,4步都是征对这个客户端处理)
3、通过客户端对象获取socket流，读取客户端发来的数据，并打印在控制台上。
4、关闭资源，需要关两个资源：客户端的和服务端的。














