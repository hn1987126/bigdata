1、父类或接口名 创建对象，用子类来 new ，这个对象如果调 属性是调 的父类的，如果调 方法则是调 子类的。
如 class A;
 class B extends A;
  A a = new B();
2、类继承了一个接口，接口里没有定义方法，而子类里有。则会编译错误。
3、父类有一个方法，如果子类里再有一个相同的，但是是prive私有的，则会出错。或者父亲和子类方法名参数名一致，但是返回值类型不一致也会编译错误，因为方法歧义。


进程：正在进行中的程序
线程：就是进程中 一个负责程序执行的控制单元（执行路径）。一个进程中至少要有一个线程，称为主线程。
多线程：多条执行路径同时进行。
开启多个线程，是为了同时运行多部分代码。每一个线程都有自己运行的内容，这个内容称为线程要执行的任务。
他们同时进行。
多线程的弊端：线程太多回收效率降低
其实应用程序的执行都是cpu在做着快速的切换完成的。这个切换是随机的。

JVM启动时就自动启了多个线程，至少有两个线程可以分析出来
1、执行main函数的线程。 该线程的任务代码都定义在main函数中。
2、负责垃圾回收的线程。  他的任务代码是在垃圾回收器里定义的。底层内部完成。
垃圾回收：System.gc();
在垃圾回收的时候，在类里，可以写个 finalize() 方法，在gc的时候，会调用那个方法，那方法里可以做一些保存呀，发消息呀之类的事件处理。
class Demo extends Object{
    public void finalize(){
        System.out.println("gc demo");
    }
}
class ThreadDemo{
    public static void main(String[] args){
        new Demo(); // 匿名类产生垃圾
        System.gc();
        System.out.println("main ok");
    }
}
主线程结束了，也就是main里的代码执行到最后一行，不代表jvm虚拟机就结束了，虚拟机里还有其他线程在执行。

创建线程方式：
继承Thread类。
实现Runnable接口。
-> 好处：1、将线程的任务从线程的子类中分离出来进行了单独封装，按面向对象的思想将任务封装成对象
2、避免了java单继承的局限性。
所以创建线程的第二种方式更常用。

主线程如果挂了，子线程还是会执行的。
CPU的执行资格   可以被cpu处理，在处理队列中排队
CPU的执行权     正在被cpu处理。

线程的5种状态：
被创建
运行状态   有cpu的执行资格和执行权
冻结状态   释放执行权的同时释放执行资格，没有cpu的执行资格和执行权。
消亡状态
临时阻塞状态     具备执行资格，但是不具备执行权，正在等待执行权，是临时阻塞。他和运行状态，两者不断的切换。
->如A,B,C,D4个线程同时执行，当cpu正在执行A的时候，bcd是临时阻塞状态。

wait()   等待   需要靠 notify() 唤醒，他才能重新争夺执行权和执行资格
sleep(1000)   等待，1秒后又重新有了执行权和执行资格。

栈内存  main方法执行，里面调了a方法，b方法，那main先入栈，a再入栈，执行完a后，a出栈，b再入栈，b执行完了b出栈，main再出栈。如果出异常，则立即出栈。
堆内存  如成员变量。

##异常会包含4部分信息：
线程，异常类型，异常信息，在什么位置。